{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useTheme } from '@mui/material/styles';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { gridPinnedColumnsSelector } from './gridColumnPinningSelector';\nimport { columnPinningStateInitializer } from './useGridColumnPinning';\nimport { filterColumns } from '../../../components/DataGridProVirtualScroller';\nexport const useGridColumnPinningPreProcessors = (apiRef, props) => {\n  const {\n    disableColumnPinning,\n    pinnedColumns: pinnedColumnsProp,\n    initialState\n  } = props;\n  const theme = useTheme();\n  let pinnedColumns = gridPinnedColumnsSelector(apiRef.current.state);\n  if (pinnedColumns == null) {\n    // Since the state is not ready yet lets use the initializer to get which\n    // columns should be pinned initially.\n    const initializedState = columnPinningStateInitializer(apiRef.current.state, {\n      disableColumnPinning,\n      pinnedColumns: pinnedColumnsProp,\n      initialState\n    }, apiRef);\n    pinnedColumns = gridPinnedColumnsSelector(initializedState);\n  }\n  const prevAllPinnedColumns = React.useRef([]);\n  const reorderPinnedColumns = React.useCallback(columnsState => {\n    if (columnsState.orderedFields.length === 0 || disableColumnPinning) {\n      return columnsState;\n    }\n    const [leftPinnedColumns, rightPinnedColumns] = filterColumns(pinnedColumns, columnsState.orderedFields, theme.direction === 'rtl');\n    let newOrderedFields;\n    const allPinnedColumns = [...leftPinnedColumns, ...rightPinnedColumns];\n    const {\n      orderedFieldsBeforePinningColumns\n    } = apiRef.current.caches.columnPinning;\n    if (orderedFieldsBeforePinningColumns) {\n      newOrderedFields = new Array(columnsState.orderedFields.length).fill(null);\n      const newOrderedFieldsBeforePinningColumns = [...newOrderedFields];\n\n      // Contains the fields not added to the orderedFields array yet\n      const remainingFields = [...columnsState.orderedFields];\n\n      // First, we check if the column was unpinned since the last processing.\n      // If yes and it still exists, we move it back to the same position it was before pinning\n      prevAllPinnedColumns.current.forEach(field => {\n        if (!allPinnedColumns.includes(field) && columnsState.lookup[field]) {\n          // Get the position before pinning\n          const index = orderedFieldsBeforePinningColumns.indexOf(field);\n          newOrderedFields[index] = field;\n          newOrderedFieldsBeforePinningColumns[index] = field;\n          // This field was already consumed so we prevent from being added again\n          remainingFields.splice(remainingFields.indexOf(field), 1);\n        }\n      });\n\n      // For columns still pinned, we keep stored their original positions\n      allPinnedColumns.forEach(field => {\n        let index = orderedFieldsBeforePinningColumns.indexOf(field);\n        // If index = -1, the pinned field didn't exist in the last processing, it's possibly being added now\n        // If index >= newOrderedFieldsBeforePinningColumns.length, then one or more columns were removed\n        // In both cases, use the position from the columns array\n        // TODO: detect removed columns and decrease the positions after it\n        if (index === -1 || index >= newOrderedFieldsBeforePinningColumns.length) {\n          index = columnsState.orderedFields.indexOf(field);\n        }\n\n        // The fallback above may make the column to be inserted in a position already occupied\n        // In this case, put it in any empty slot available\n        if (newOrderedFieldsBeforePinningColumns[index] !== null) {\n          index = 0;\n          while (newOrderedFieldsBeforePinningColumns[index] !== null) {\n            index += 1;\n          }\n        }\n        newOrderedFields[index] = field;\n        newOrderedFieldsBeforePinningColumns[index] = field;\n        // This field was already consumed so we prevent from being added again\n        remainingFields.splice(remainingFields.indexOf(field), 1);\n      });\n\n      // The fields remaining are those that're neither pinnned nor were unpinned\n      // For these, we spread them across both arrays making sure to not override existing values\n      let i = 0;\n      remainingFields.forEach(field => {\n        while (newOrderedFieldsBeforePinningColumns[i] !== null) {\n          i += 1;\n        }\n        newOrderedFieldsBeforePinningColumns[i] = field;\n        newOrderedFields[i] = field;\n      });\n      apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns = newOrderedFieldsBeforePinningColumns;\n    } else {\n      newOrderedFields = [...columnsState.orderedFields];\n      apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns = [...columnsState.orderedFields];\n    }\n    prevAllPinnedColumns.current = allPinnedColumns;\n    const centerColumns = newOrderedFields.filter(field => {\n      return !leftPinnedColumns.includes(field) && !rightPinnedColumns.includes(field);\n    });\n    return _extends({}, columnsState, {\n      orderedFields: [...leftPinnedColumns, ...centerColumns, ...rightPinnedColumns]\n    });\n  }, [apiRef, disableColumnPinning, pinnedColumns, theme.direction]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateColumns', reorderPinnedColumns);\n};","map":{"version":3,"names":["_extends","React","useTheme","useGridRegisterPipeProcessor","gridPinnedColumnsSelector","columnPinningStateInitializer","filterColumns","useGridColumnPinningPreProcessors","apiRef","props","disableColumnPinning","pinnedColumns","pinnedColumnsProp","initialState","theme","current","state","initializedState","prevAllPinnedColumns","useRef","reorderPinnedColumns","useCallback","columnsState","orderedFields","length","leftPinnedColumns","rightPinnedColumns","direction","newOrderedFields","allPinnedColumns","orderedFieldsBeforePinningColumns","caches","columnPinning","Array","fill","newOrderedFieldsBeforePinningColumns","remainingFields","forEach","field","includes","lookup","index","indexOf","splice","i","centerColumns","filter"],"sources":["/Users/shyamkansagra/Documents/Code/general/pocket-wallet/node_modules/@mui/x-data-grid-pro/hooks/features/columnPinning/useGridColumnPinningPreProcessors.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useTheme } from '@mui/material/styles';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { gridPinnedColumnsSelector } from './gridColumnPinningSelector';\nimport { columnPinningStateInitializer } from './useGridColumnPinning';\nimport { filterColumns } from '../../../components/DataGridProVirtualScroller';\nexport const useGridColumnPinningPreProcessors = (apiRef, props) => {\n  const {\n    disableColumnPinning,\n    pinnedColumns: pinnedColumnsProp,\n    initialState\n  } = props;\n  const theme = useTheme();\n  let pinnedColumns = gridPinnedColumnsSelector(apiRef.current.state);\n  if (pinnedColumns == null) {\n    // Since the state is not ready yet lets use the initializer to get which\n    // columns should be pinned initially.\n    const initializedState = columnPinningStateInitializer(apiRef.current.state, {\n      disableColumnPinning,\n      pinnedColumns: pinnedColumnsProp,\n      initialState\n    }, apiRef);\n    pinnedColumns = gridPinnedColumnsSelector(initializedState);\n  }\n  const prevAllPinnedColumns = React.useRef([]);\n  const reorderPinnedColumns = React.useCallback(columnsState => {\n    if (columnsState.orderedFields.length === 0 || disableColumnPinning) {\n      return columnsState;\n    }\n    const [leftPinnedColumns, rightPinnedColumns] = filterColumns(pinnedColumns, columnsState.orderedFields, theme.direction === 'rtl');\n    let newOrderedFields;\n    const allPinnedColumns = [...leftPinnedColumns, ...rightPinnedColumns];\n    const {\n      orderedFieldsBeforePinningColumns\n    } = apiRef.current.caches.columnPinning;\n    if (orderedFieldsBeforePinningColumns) {\n      newOrderedFields = new Array(columnsState.orderedFields.length).fill(null);\n      const newOrderedFieldsBeforePinningColumns = [...newOrderedFields];\n\n      // Contains the fields not added to the orderedFields array yet\n      const remainingFields = [...columnsState.orderedFields];\n\n      // First, we check if the column was unpinned since the last processing.\n      // If yes and it still exists, we move it back to the same position it was before pinning\n      prevAllPinnedColumns.current.forEach(field => {\n        if (!allPinnedColumns.includes(field) && columnsState.lookup[field]) {\n          // Get the position before pinning\n          const index = orderedFieldsBeforePinningColumns.indexOf(field);\n          newOrderedFields[index] = field;\n          newOrderedFieldsBeforePinningColumns[index] = field;\n          // This field was already consumed so we prevent from being added again\n          remainingFields.splice(remainingFields.indexOf(field), 1);\n        }\n      });\n\n      // For columns still pinned, we keep stored their original positions\n      allPinnedColumns.forEach(field => {\n        let index = orderedFieldsBeforePinningColumns.indexOf(field);\n        // If index = -1, the pinned field didn't exist in the last processing, it's possibly being added now\n        // If index >= newOrderedFieldsBeforePinningColumns.length, then one or more columns were removed\n        // In both cases, use the position from the columns array\n        // TODO: detect removed columns and decrease the positions after it\n        if (index === -1 || index >= newOrderedFieldsBeforePinningColumns.length) {\n          index = columnsState.orderedFields.indexOf(field);\n        }\n\n        // The fallback above may make the column to be inserted in a position already occupied\n        // In this case, put it in any empty slot available\n        if (newOrderedFieldsBeforePinningColumns[index] !== null) {\n          index = 0;\n          while (newOrderedFieldsBeforePinningColumns[index] !== null) {\n            index += 1;\n          }\n        }\n        newOrderedFields[index] = field;\n        newOrderedFieldsBeforePinningColumns[index] = field;\n        // This field was already consumed so we prevent from being added again\n        remainingFields.splice(remainingFields.indexOf(field), 1);\n      });\n\n      // The fields remaining are those that're neither pinnned nor were unpinned\n      // For these, we spread them across both arrays making sure to not override existing values\n      let i = 0;\n      remainingFields.forEach(field => {\n        while (newOrderedFieldsBeforePinningColumns[i] !== null) {\n          i += 1;\n        }\n        newOrderedFieldsBeforePinningColumns[i] = field;\n        newOrderedFields[i] = field;\n      });\n      apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns = newOrderedFieldsBeforePinningColumns;\n    } else {\n      newOrderedFields = [...columnsState.orderedFields];\n      apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns = [...columnsState.orderedFields];\n    }\n    prevAllPinnedColumns.current = allPinnedColumns;\n    const centerColumns = newOrderedFields.filter(field => {\n      return !leftPinnedColumns.includes(field) && !rightPinnedColumns.includes(field);\n    });\n    return _extends({}, columnsState, {\n      orderedFields: [...leftPinnedColumns, ...centerColumns, ...rightPinnedColumns]\n    });\n  }, [apiRef, disableColumnPinning, pinnedColumns, theme.direction]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateColumns', reorderPinnedColumns);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}