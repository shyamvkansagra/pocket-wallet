{"ast":null,"code":"import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { getNodePathInTree, getGroupRowIdFromPath, removeNodeFromTree, updateGroupNodeIdAndAutoGenerated } from './utils';\nconst removeNodeAndCleanParent = ({\n  node,\n  tree,\n  treeDepths,\n  updatedGroupsManager\n}) => {\n  removeNodeFromTree({\n    node,\n    tree,\n    treeDepths\n  });\n  if (node.type === 'group' && node.footerId != null) {\n    removeNodeFromTree({\n      node: tree[node.footerId],\n      tree,\n      treeDepths\n    });\n  }\n  const parentNode = tree[node.parent];\n  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNode.id, 'removeChildren');\n  const shouldDeleteGroup = parentNode.id !== GRID_ROOT_GROUP_ID && parentNode.children.length === 0;\n  if (shouldDeleteGroup) {\n    if (parentNode.isAutoGenerated) {\n      removeNodeAndCleanParent({\n        node: parentNode,\n        tree,\n        treeDepths\n      });\n    } else {\n      tree[parentNode.id] = {\n        type: 'leaf',\n        id: parentNode.id,\n        depth: parentNode.depth,\n        parent: parentNode.parent,\n        groupingKey: parentNode.groupingKey\n      };\n    }\n  }\n};\nconst replaceDataGroupWithAutoGeneratedGroup = ({\n  node,\n  tree,\n  treeDepths,\n  updatedGroupsManager\n}) => {\n  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(node.parent, 'removeChildren');\n  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(node.parent, 'insertChildren');\n  updateGroupNodeIdAndAutoGenerated({\n    previousTree: null,\n    tree,\n    treeDepths,\n    node,\n    updatedNode: {\n      id: getGroupRowIdFromPath(getNodePathInTree({\n        id: node.id,\n        tree\n      })),\n      isAutoGenerated: true\n    }\n  });\n};\n\n/**\n * Removed a data row from the tree.\n * If the node is a non-empty group, replace it with an auto-generated group to be able to keep displaying its children.\n * If not, remove it and recursively clean its parent with the following rules:\n * - An empty auto-generated should be removed from the tree\n * - An empty non-auto-generated should be turned into a leaf\n */\nexport const removeDataRowFromTree = ({\n  id,\n  tree,\n  treeDepths,\n  updatedGroupsManager\n}) => {\n  const node = tree[id];\n  if (node.type === 'group' && node.children.length > 0) {\n    replaceDataGroupWithAutoGeneratedGroup({\n      node,\n      tree,\n      treeDepths,\n      updatedGroupsManager\n    });\n  } else {\n    removeNodeAndCleanParent({\n      node,\n      tree,\n      treeDepths,\n      updatedGroupsManager\n    });\n  }\n};","map":{"version":3,"names":["GRID_ROOT_GROUP_ID","getNodePathInTree","getGroupRowIdFromPath","removeNodeFromTree","updateGroupNodeIdAndAutoGenerated","removeNodeAndCleanParent","node","tree","treeDepths","updatedGroupsManager","type","footerId","parentNode","parent","addAction","id","shouldDeleteGroup","children","length","isAutoGenerated","depth","groupingKey","replaceDataGroupWithAutoGeneratedGroup","previousTree","updatedNode","removeDataRowFromTree"],"sources":["/Users/shyamkansagra/Documents/Code/general/pocket-wallet/node_modules/@mui/x-data-grid-pro/utils/tree/removeDataRowFromTree.js"],"sourcesContent":["import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { getNodePathInTree, getGroupRowIdFromPath, removeNodeFromTree, updateGroupNodeIdAndAutoGenerated } from './utils';\nconst removeNodeAndCleanParent = ({\n  node,\n  tree,\n  treeDepths,\n  updatedGroupsManager\n}) => {\n  removeNodeFromTree({\n    node,\n    tree,\n    treeDepths\n  });\n  if (node.type === 'group' && node.footerId != null) {\n    removeNodeFromTree({\n      node: tree[node.footerId],\n      tree,\n      treeDepths\n    });\n  }\n  const parentNode = tree[node.parent];\n  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNode.id, 'removeChildren');\n  const shouldDeleteGroup = parentNode.id !== GRID_ROOT_GROUP_ID && parentNode.children.length === 0;\n  if (shouldDeleteGroup) {\n    if (parentNode.isAutoGenerated) {\n      removeNodeAndCleanParent({\n        node: parentNode,\n        tree,\n        treeDepths\n      });\n    } else {\n      tree[parentNode.id] = {\n        type: 'leaf',\n        id: parentNode.id,\n        depth: parentNode.depth,\n        parent: parentNode.parent,\n        groupingKey: parentNode.groupingKey\n      };\n    }\n  }\n};\nconst replaceDataGroupWithAutoGeneratedGroup = ({\n  node,\n  tree,\n  treeDepths,\n  updatedGroupsManager\n}) => {\n  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(node.parent, 'removeChildren');\n  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(node.parent, 'insertChildren');\n  updateGroupNodeIdAndAutoGenerated({\n    previousTree: null,\n    tree,\n    treeDepths,\n    node,\n    updatedNode: {\n      id: getGroupRowIdFromPath(getNodePathInTree({\n        id: node.id,\n        tree\n      })),\n      isAutoGenerated: true\n    }\n  });\n};\n\n/**\n * Removed a data row from the tree.\n * If the node is a non-empty group, replace it with an auto-generated group to be able to keep displaying its children.\n * If not, remove it and recursively clean its parent with the following rules:\n * - An empty auto-generated should be removed from the tree\n * - An empty non-auto-generated should be turned into a leaf\n */\nexport const removeDataRowFromTree = ({\n  id,\n  tree,\n  treeDepths,\n  updatedGroupsManager\n}) => {\n  const node = tree[id];\n  if (node.type === 'group' && node.children.length > 0) {\n    replaceDataGroupWithAutoGeneratedGroup({\n      node,\n      tree,\n      treeDepths,\n      updatedGroupsManager\n    });\n  } else {\n    removeNodeAndCleanParent({\n      node,\n      tree,\n      treeDepths,\n      updatedGroupsManager\n    });\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}