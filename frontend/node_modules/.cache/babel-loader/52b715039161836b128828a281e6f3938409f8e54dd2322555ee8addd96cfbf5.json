{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { unstable_capitalize as capitalize } from '@mui/utils';\nimport { GRID_ID_AUTOGENERATED } from '@mui/x-data-grid/internals';\nimport { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid-pro';\nimport { addPinnedRow, isDeepEqual, insertNodeInTree, removeNodeFromTree } from '@mui/x-data-grid-pro/internals';\nexport const GRID_AGGREGATION_ROOT_FOOTER_ROW_ID = 'auto-generated-group-footer-root';\nexport const getAggregationFooterRowIdFromGroupId = groupId => {\n  if (groupId == null) {\n    return GRID_AGGREGATION_ROOT_FOOTER_ROW_ID;\n  }\n  return `auto-generated-group-footer-${groupId}`;\n};\nexport const canColumnHaveAggregationFunction = ({\n  colDef,\n  aggregationFunctionName,\n  aggregationFunction\n}) => {\n  if (!colDef || !colDef.aggregable) {\n    return false;\n  }\n  if (!aggregationFunction) {\n    return false;\n  }\n  if (colDef.availableAggregationFunctions != null) {\n    return colDef.availableAggregationFunctions.includes(aggregationFunctionName);\n  }\n  if (!aggregationFunction.columnTypes) {\n    return true;\n  }\n  return aggregationFunction.columnTypes.includes(colDef.type);\n};\nexport const getAvailableAggregationFunctions = ({\n  aggregationFunctions,\n  colDef\n}) => Object.keys(aggregationFunctions).filter(aggregationFunctionName => canColumnHaveAggregationFunction({\n  colDef,\n  aggregationFunctionName,\n  aggregationFunction: aggregationFunctions[aggregationFunctionName]\n}));\nexport const mergeStateWithAggregationModel = aggregationModel => state => _extends({}, state, {\n  aggregation: _extends({}, state.aggregation, {\n    model: aggregationModel\n  })\n});\nexport const getAggregationRules = ({\n  columnsLookup,\n  aggregationModel,\n  aggregationFunctions\n}) => {\n  const aggregationRules = {};\n  Object.entries(aggregationModel).forEach(([field, columnItem]) => {\n    if (columnsLookup[field] && canColumnHaveAggregationFunction({\n      colDef: columnsLookup[field],\n      aggregationFunctionName: columnItem,\n      aggregationFunction: aggregationFunctions[columnItem]\n    })) {\n      aggregationRules[field] = {\n        aggregationFunctionName: columnItem,\n        aggregationFunction: aggregationFunctions[columnItem]\n      };\n    }\n  });\n  return aggregationRules;\n};\n/**\n * Add a footer for each group that has at least one column with an aggregated value.\n */\nexport const addFooterRows = ({\n  groupingParams,\n  apiRef,\n  getAggregationPosition,\n  hasAggregationRule\n}) => {\n  let newGroupingParams = _extends({}, groupingParams, {\n    tree: _extends({}, groupingParams.tree),\n    treeDepths: _extends({}, groupingParams.treeDepths)\n  });\n  const updateChildGroupFooter = groupNode => {\n    const shouldHaveFooter = hasAggregationRule && getAggregationPosition(groupNode) === 'footer';\n    if (shouldHaveFooter) {\n      const footerId = getAggregationFooterRowIdFromGroupId(groupNode.id);\n      if (groupNode.footerId !== footerId) {\n        if (groupNode.footerId != null) {\n          removeNodeFromTree({\n            node: newGroupingParams.tree[groupNode.footerId],\n            tree: newGroupingParams.tree,\n            treeDepths: newGroupingParams.treeDepths\n          });\n        }\n        const footerNode = {\n          id: footerId,\n          parent: groupNode.id,\n          depth: groupNode ? groupNode.depth + 1 : 0,\n          type: 'footer'\n        };\n        insertNodeInTree(footerNode, newGroupingParams.tree, newGroupingParams.treeDepths, null);\n      }\n    } else if (groupNode.footerId != null) {\n      removeNodeFromTree({\n        node: newGroupingParams.tree[groupNode.footerId],\n        tree: newGroupingParams.tree,\n        treeDepths: newGroupingParams.treeDepths\n      });\n      newGroupingParams.tree[groupNode.id] = _extends({}, newGroupingParams.tree[groupNode.id], {\n        footerId: null\n      });\n    }\n  };\n  const updateRootGroupFooter = groupNode => {\n    const shouldHaveFooter = hasAggregationRule && getAggregationPosition(groupNode) === 'footer';\n    if (shouldHaveFooter) {\n      const rowId = getAggregationFooterRowIdFromGroupId(null);\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: {\n          [GRID_ID_AUTOGENERATED]: rowId\n        },\n        rowId,\n        position: 'bottom',\n        apiRef,\n        isAutoGenerated: true\n      });\n    }\n  };\n  const updateGroupFooter = groupNode => {\n    if (groupNode.id === GRID_ROOT_GROUP_ID) {\n      updateRootGroupFooter(groupNode);\n    } else {\n      updateChildGroupFooter(groupNode);\n    }\n    groupNode.children.forEach(childId => {\n      const childNode = newGroupingParams.tree[childId];\n      if (childNode.type === 'group') {\n        updateGroupFooter(childNode);\n      }\n    });\n  };\n  updateGroupFooter(newGroupingParams.tree[GRID_ROOT_GROUP_ID]);\n  return newGroupingParams;\n};\n\n/**\n * Compares two sets of aggregation rules to determine if they are equal or not.\n */\nexport const areAggregationRulesEqual = (previousValue, newValue) => {\n  const previousFields = Object.keys(previousValue != null ? previousValue : {});\n  const newFields = Object.keys(newValue);\n  if (!isDeepEqual(previousFields, newFields)) {\n    return false;\n  }\n  return newFields.every(field => {\n    const previousRule = previousValue == null ? void 0 : previousValue[field];\n    const newRule = newValue[field];\n    if ((previousRule == null ? void 0 : previousRule.aggregationFunction) !== (newRule == null ? void 0 : newRule.aggregationFunction)) {\n      return false;\n    }\n    if ((previousRule == null ? void 0 : previousRule.aggregationFunctionName) !== (newRule == null ? void 0 : newRule.aggregationFunctionName)) {\n      return false;\n    }\n    return true;\n  });\n};\nexport const getAggregationFunctionLabel = ({\n  apiRef,\n  aggregationRule\n}) => {\n  if (aggregationRule.aggregationFunction.label != null) {\n    return aggregationRule.aggregationFunction.label;\n  }\n  try {\n    return apiRef.current.getLocaleText(`aggregationFunctionLabel${capitalize(aggregationRule.aggregationFunctionName)}`);\n  } catch (e) {\n    return aggregationRule.aggregationFunctionName;\n  }\n};","map":{"version":3,"names":["_extends","unstable_capitalize","capitalize","GRID_ID_AUTOGENERATED","GRID_ROOT_GROUP_ID","addPinnedRow","isDeepEqual","insertNodeInTree","removeNodeFromTree","GRID_AGGREGATION_ROOT_FOOTER_ROW_ID","getAggregationFooterRowIdFromGroupId","groupId","canColumnHaveAggregationFunction","colDef","aggregationFunctionName","aggregationFunction","aggregable","availableAggregationFunctions","includes","columnTypes","type","getAvailableAggregationFunctions","aggregationFunctions","Object","keys","filter","mergeStateWithAggregationModel","aggregationModel","state","aggregation","model","getAggregationRules","columnsLookup","aggregationRules","entries","forEach","field","columnItem","addFooterRows","groupingParams","apiRef","getAggregationPosition","hasAggregationRule","newGroupingParams","tree","treeDepths","updateChildGroupFooter","groupNode","shouldHaveFooter","footerId","id","node","footerNode","parent","depth","updateRootGroupFooter","rowId","rowModel","position","isAutoGenerated","updateGroupFooter","children","childId","childNode","areAggregationRulesEqual","previousValue","newValue","previousFields","newFields","every","previousRule","newRule","getAggregationFunctionLabel","aggregationRule","label","current","getLocaleText","e"],"sources":["/Users/shyamkansagra/Documents/Code/general/pocket-wallet/node_modules/@mui/x-data-grid-premium/hooks/features/aggregation/gridAggregationUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { unstable_capitalize as capitalize } from '@mui/utils';\nimport { GRID_ID_AUTOGENERATED } from '@mui/x-data-grid/internals';\nimport { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid-pro';\nimport { addPinnedRow, isDeepEqual, insertNodeInTree, removeNodeFromTree } from '@mui/x-data-grid-pro/internals';\nexport const GRID_AGGREGATION_ROOT_FOOTER_ROW_ID = 'auto-generated-group-footer-root';\nexport const getAggregationFooterRowIdFromGroupId = groupId => {\n  if (groupId == null) {\n    return GRID_AGGREGATION_ROOT_FOOTER_ROW_ID;\n  }\n  return `auto-generated-group-footer-${groupId}`;\n};\nexport const canColumnHaveAggregationFunction = ({\n  colDef,\n  aggregationFunctionName,\n  aggregationFunction\n}) => {\n  if (!colDef || !colDef.aggregable) {\n    return false;\n  }\n  if (!aggregationFunction) {\n    return false;\n  }\n  if (colDef.availableAggregationFunctions != null) {\n    return colDef.availableAggregationFunctions.includes(aggregationFunctionName);\n  }\n  if (!aggregationFunction.columnTypes) {\n    return true;\n  }\n  return aggregationFunction.columnTypes.includes(colDef.type);\n};\nexport const getAvailableAggregationFunctions = ({\n  aggregationFunctions,\n  colDef\n}) => Object.keys(aggregationFunctions).filter(aggregationFunctionName => canColumnHaveAggregationFunction({\n  colDef,\n  aggregationFunctionName,\n  aggregationFunction: aggregationFunctions[aggregationFunctionName]\n}));\nexport const mergeStateWithAggregationModel = aggregationModel => state => _extends({}, state, {\n  aggregation: _extends({}, state.aggregation, {\n    model: aggregationModel\n  })\n});\nexport const getAggregationRules = ({\n  columnsLookup,\n  aggregationModel,\n  aggregationFunctions\n}) => {\n  const aggregationRules = {};\n  Object.entries(aggregationModel).forEach(([field, columnItem]) => {\n    if (columnsLookup[field] && canColumnHaveAggregationFunction({\n      colDef: columnsLookup[field],\n      aggregationFunctionName: columnItem,\n      aggregationFunction: aggregationFunctions[columnItem]\n    })) {\n      aggregationRules[field] = {\n        aggregationFunctionName: columnItem,\n        aggregationFunction: aggregationFunctions[columnItem]\n      };\n    }\n  });\n  return aggregationRules;\n};\n/**\n * Add a footer for each group that has at least one column with an aggregated value.\n */\nexport const addFooterRows = ({\n  groupingParams,\n  apiRef,\n  getAggregationPosition,\n  hasAggregationRule\n}) => {\n  let newGroupingParams = _extends({}, groupingParams, {\n    tree: _extends({}, groupingParams.tree),\n    treeDepths: _extends({}, groupingParams.treeDepths)\n  });\n  const updateChildGroupFooter = groupNode => {\n    const shouldHaveFooter = hasAggregationRule && getAggregationPosition(groupNode) === 'footer';\n    if (shouldHaveFooter) {\n      const footerId = getAggregationFooterRowIdFromGroupId(groupNode.id);\n      if (groupNode.footerId !== footerId) {\n        if (groupNode.footerId != null) {\n          removeNodeFromTree({\n            node: newGroupingParams.tree[groupNode.footerId],\n            tree: newGroupingParams.tree,\n            treeDepths: newGroupingParams.treeDepths\n          });\n        }\n        const footerNode = {\n          id: footerId,\n          parent: groupNode.id,\n          depth: groupNode ? groupNode.depth + 1 : 0,\n          type: 'footer'\n        };\n        insertNodeInTree(footerNode, newGroupingParams.tree, newGroupingParams.treeDepths, null);\n      }\n    } else if (groupNode.footerId != null) {\n      removeNodeFromTree({\n        node: newGroupingParams.tree[groupNode.footerId],\n        tree: newGroupingParams.tree,\n        treeDepths: newGroupingParams.treeDepths\n      });\n      newGroupingParams.tree[groupNode.id] = _extends({}, newGroupingParams.tree[groupNode.id], {\n        footerId: null\n      });\n    }\n  };\n  const updateRootGroupFooter = groupNode => {\n    const shouldHaveFooter = hasAggregationRule && getAggregationPosition(groupNode) === 'footer';\n    if (shouldHaveFooter) {\n      const rowId = getAggregationFooterRowIdFromGroupId(null);\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: {\n          [GRID_ID_AUTOGENERATED]: rowId\n        },\n        rowId,\n        position: 'bottom',\n        apiRef,\n        isAutoGenerated: true\n      });\n    }\n  };\n  const updateGroupFooter = groupNode => {\n    if (groupNode.id === GRID_ROOT_GROUP_ID) {\n      updateRootGroupFooter(groupNode);\n    } else {\n      updateChildGroupFooter(groupNode);\n    }\n    groupNode.children.forEach(childId => {\n      const childNode = newGroupingParams.tree[childId];\n      if (childNode.type === 'group') {\n        updateGroupFooter(childNode);\n      }\n    });\n  };\n  updateGroupFooter(newGroupingParams.tree[GRID_ROOT_GROUP_ID]);\n  return newGroupingParams;\n};\n\n/**\n * Compares two sets of aggregation rules to determine if they are equal or not.\n */\nexport const areAggregationRulesEqual = (previousValue, newValue) => {\n  const previousFields = Object.keys(previousValue != null ? previousValue : {});\n  const newFields = Object.keys(newValue);\n  if (!isDeepEqual(previousFields, newFields)) {\n    return false;\n  }\n  return newFields.every(field => {\n    const previousRule = previousValue == null ? void 0 : previousValue[field];\n    const newRule = newValue[field];\n    if ((previousRule == null ? void 0 : previousRule.aggregationFunction) !== (newRule == null ? void 0 : newRule.aggregationFunction)) {\n      return false;\n    }\n    if ((previousRule == null ? void 0 : previousRule.aggregationFunctionName) !== (newRule == null ? void 0 : newRule.aggregationFunctionName)) {\n      return false;\n    }\n    return true;\n  });\n};\nexport const getAggregationFunctionLabel = ({\n  apiRef,\n  aggregationRule\n}) => {\n  if (aggregationRule.aggregationFunction.label != null) {\n    return aggregationRule.aggregationFunction.label;\n  }\n  try {\n    return apiRef.current.getLocaleText(`aggregationFunctionLabel${capitalize(aggregationRule.aggregationFunctionName)}`);\n  } catch (e) {\n    return aggregationRule.aggregationFunctionName;\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}