{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GRID_DATE_COL_DEF, GRID_DATETIME_COL_DEF } from '@mui/x-data-grid-pro';\nimport { buildWarning, isObject, isSingleSelectColDef } from '@mui/x-data-grid/internals';\nconst getExcelJs = async () => {\n  var _excelJsModule$defaul;\n  const excelJsModule = await import('exceljs');\n  return (_excelJsModule$defaul = excelJsModule.default) != null ? _excelJsModule$defaul : excelJsModule;\n};\nconst warnInvalidFormattedValue = buildWarning(['MUI: When the value of a field is an object or a `renderCell` is provided, the Excel export might not display the value correctly.', 'You can provide a `valueFormatter` with a string representation to be used.']);\nconst getFormattedValueOptions = (colDef, valueOptions, api) => {\n  if (!colDef.valueOptions) {\n    return [];\n  }\n  let valueOptionsFormatted = valueOptions;\n  if (colDef.valueFormatter) {\n    valueOptionsFormatted = valueOptionsFormatted.map(option => {\n      if (typeof option === 'object') {\n        return option;\n      }\n      const params = {\n        field: colDef.field,\n        api,\n        value: option\n      };\n      return String(colDef.valueFormatter(params));\n    });\n  }\n  return valueOptionsFormatted.map(option => typeof option === 'object' ? option.label : option);\n};\nexport const serializeRow = (id, columns, api, defaultValueOptionsFormulae) => {\n  const row = {};\n  const dataValidation = {};\n  const mergedCells = [];\n  const firstCellParams = api.getCellParams(id, columns[0].field);\n  const outlineLevel = firstCellParams.rowNode.depth;\n\n  // `colSpan` is only calculated for rendered rows, so we need to calculate it during export for every row\n  api.calculateColSpan({\n    rowId: id,\n    minFirstColumn: 0,\n    maxLastColumn: columns.length,\n    columns\n  });\n  columns.forEach((column, colIndex) => {\n    const colSpanInfo = api.unstable_getCellColSpanInfo(id, colIndex);\n    if (colSpanInfo && colSpanInfo.spannedByColSpan) {\n      return;\n    }\n    if (colSpanInfo && colSpanInfo.cellProps.colSpan > 1) {\n      mergedCells.push({\n        leftIndex: colIndex + 1,\n        rightIndex: colIndex + colSpanInfo.cellProps.colSpan\n      });\n    }\n    const cellParams = api.getCellParams(id, column.field);\n    switch (cellParams.colDef.type) {\n      case 'singleSelect':\n        {\n          const castColumn = cellParams.colDef;\n          if (typeof castColumn.valueOptions === 'function') {\n            // If value option depends on the row, set specific options to the cell\n            // This dataValidation is buggy with LibreOffice and does not allow to have coma\n            const valueOptions = castColumn.valueOptions({\n              id,\n              row,\n              field: cellParams.field\n            });\n            const formattedValueOptions = getFormattedValueOptions(castColumn, valueOptions, api);\n            dataValidation[castColumn.field] = {\n              type: 'list',\n              allowBlank: true,\n              formulae: [`\"${formattedValueOptions.map(x => x.toString().replaceAll(',', 'CHAR(44)')).join(',')}\"`]\n            };\n          } else {\n            const address = defaultValueOptionsFormulae[column.field].address;\n\n            // If value option is defined for the column, refer to another sheet\n            dataValidation[castColumn.field] = {\n              type: 'list',\n              allowBlank: true,\n              formulae: [address]\n            };\n          }\n          const formattedValue = api.getCellParams(id, castColumn.field).formattedValue;\n          if (process.env.NODE_ENV !== 'production') {\n            if (String(cellParams.formattedValue) === '[object Object]') {\n              warnInvalidFormattedValue();\n            }\n          }\n          if (isObject(formattedValue)) {\n            row[castColumn.field] = formattedValue == null ? void 0 : formattedValue.label;\n          } else {\n            row[castColumn.field] = formattedValue;\n          }\n          break;\n        }\n      case 'boolean':\n      case 'number':\n        row[column.field] = api.getCellParams(id, column.field).value;\n        break;\n      case 'date':\n      case 'dateTime':\n        {\n          // Excel does not do any timezone conversion, so we create a date using UTC instead of local timezone\n          // Solution from: https://github.com/exceljs/exceljs/issues/486#issuecomment-432557582\n          // About Date.UTC(): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/UTC#exemples\n          const value = api.getCellParams(id, column.field).value;\n          // value may be `undefined` in auto-generated grouping rows\n          if (!value) {\n            break;\n          }\n          const utcDate = new Date(Date.UTC(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds()));\n          row[column.field] = utcDate;\n          break;\n        }\n      case 'actions':\n        break;\n      default:\n        row[column.field] = api.getCellParams(id, column.field).formattedValue;\n        if (process.env.NODE_ENV !== 'production') {\n          if (String(cellParams.formattedValue) === '[object Object]') {\n            warnInvalidFormattedValue();\n          }\n        }\n        break;\n    }\n  });\n  return {\n    row,\n    dataValidation,\n    outlineLevel,\n    mergedCells\n  };\n};\nconst defaultColumnsStyles = {\n  [GRID_DATE_COL_DEF.type]: {\n    numFmt: 'dd.mm.yyyy'\n  },\n  [GRID_DATETIME_COL_DEF.type]: {\n    numFmt: 'dd.mm.yyyy hh:mm'\n  }\n};\nexport const serializeColumn = (column, columnsStyles) => {\n  var _column$headerName;\n  const {\n    field,\n    type\n  } = column;\n  return {\n    key: field,\n    headerText: (_column$headerName = column.headerName) != null ? _column$headerName : column.field,\n    // Excel width must stay between 0 and 255 (https://support.microsoft.com/en-us/office/change-the-column-width-and-row-height-72f5e3cc-994d-43e8-ae58-9774a0905f46)\n    // From the example of column width behavior (https://docs.microsoft.com/en-US/office/troubleshoot/excel/determine-column-widths#example-of-column-width-behavior)\n    // a value of 10 corresponds to 75px. This is an approximation, because column width depends on the font-size\n    width: Math.min(255, column.width ? column.width / 7.5 : 8.43),\n    style: _extends({}, type && (defaultColumnsStyles == null ? void 0 : defaultColumnsStyles[type]), columnsStyles == null ? void 0 : columnsStyles[field])\n  };\n};\nconst addColumnGroupingHeaders = (worksheet, columns, columnGroupPaths, columnGroupDetails) => {\n  const maxDepth = Math.max(...columns.map(({\n    key\n  }) => {\n    var _columnGroupPaths$key, _columnGroupPaths$key2;\n    return (_columnGroupPaths$key = (_columnGroupPaths$key2 = columnGroupPaths[key]) == null ? void 0 : _columnGroupPaths$key2.length) != null ? _columnGroupPaths$key : 0;\n  }));\n  if (maxDepth === 0) {\n    return;\n  }\n  for (let rowIndex = 0; rowIndex < maxDepth; rowIndex += 1) {\n    const row = columns.map(({\n      key\n    }) => {\n      const groupingPath = columnGroupPaths[key];\n      if (groupingPath.length <= rowIndex) {\n        return {\n          groupId: null,\n          parents: groupingPath\n        };\n      }\n      return _extends({}, columnGroupDetails[groupingPath[rowIndex]], {\n        parents: groupingPath.slice(0, rowIndex)\n      });\n    });\n    const newRow = worksheet.addRow(row.map(group => {\n      var _group$headerName;\n      return group.groupId === null ? null : (_group$headerName = group == null ? void 0 : group.headerName) != null ? _group$headerName : group.groupId;\n    }));\n\n    // use `rowCount`, since worksheet can have additional rows added in `exceljsPreProcess`\n    const lastRowIndex = newRow.worksheet.rowCount;\n    let leftIndex = 0;\n    let rightIndex = 1;\n    while (rightIndex < columns.length) {\n      const {\n        groupId: leftGroupId,\n        parents: leftParents\n      } = row[leftIndex];\n      const {\n        groupId: rightGroupId,\n        parents: rightParents\n      } = row[rightIndex];\n      const areInSameGroup = leftGroupId === rightGroupId && leftParents.length === rightParents.length && leftParents.every((leftParent, index) => rightParents[index] === leftParent);\n      if (areInSameGroup) {\n        rightIndex += 1;\n      } else {\n        if (rightIndex - leftIndex > 1) {\n          worksheet.mergeCells(lastRowIndex, leftIndex + 1, lastRowIndex, rightIndex);\n        }\n        leftIndex = rightIndex;\n        rightIndex += 1;\n      }\n    }\n    if (rightIndex - leftIndex > 1) {\n      worksheet.mergeCells(lastRowIndex, leftIndex + 1, lastRowIndex, rightIndex);\n    }\n  }\n};\nexport function serializeColumns(columns, styles) {\n  return columns.map(column => serializeColumn(column, styles));\n}\nexport async function getDataForValueOptionsSheet(columns, valueOptionsSheetName, api) {\n  const candidateColumns = columns.filter(column => isSingleSelectColDef(column) && Array.isArray(column.valueOptions));\n\n  // Creates a temp worksheet to obtain the column letters\n  const excelJS = await getExcelJs();\n  const workbook = new excelJS.Workbook();\n  const worksheet = workbook.addWorksheet('Sheet1');\n  worksheet.columns = candidateColumns.map(column => ({\n    key: column.field\n  }));\n  return candidateColumns.reduce((acc, column) => {\n    var _column$headerName2;\n    const singleSelectColumn = column;\n    const formattedValueOptions = getFormattedValueOptions(singleSelectColumn, singleSelectColumn.valueOptions, api);\n    const header = (_column$headerName2 = column.headerName) != null ? _column$headerName2 : column.field;\n    const values = [header, ...formattedValueOptions];\n    const letter = worksheet.getColumn(column.field).letter;\n    const address = `${valueOptionsSheetName}!$${letter}$2:$${letter}$${values.length}`;\n    acc[column.field] = {\n      values,\n      address\n    };\n    return acc;\n  }, {});\n}\nfunction addSerializedRowToWorksheet(serializedRow, worksheet) {\n  const {\n    row,\n    dataValidation,\n    outlineLevel,\n    mergedCells\n  } = serializedRow;\n  const newRow = worksheet.addRow(row);\n  Object.keys(dataValidation).forEach(field => {\n    newRow.getCell(field).dataValidation = _extends({}, dataValidation[field]);\n  });\n  if (outlineLevel) {\n    newRow.outlineLevel = outlineLevel;\n  }\n\n  // use `rowCount`, since worksheet can have additional rows added in `exceljsPreProcess`\n  const lastRowIndex = newRow.worksheet.rowCount;\n  mergedCells.forEach(mergedCell => {\n    worksheet.mergeCells(lastRowIndex, mergedCell.leftIndex, lastRowIndex, mergedCell.rightIndex);\n  });\n}\nasync function createValueOptionsSheetIfNeeded(valueOptionsData, sheetName, workbook) {\n  if (Object.keys(valueOptionsData).length === 0) {\n    return;\n  }\n  const valueOptionsWorksheet = workbook.addWorksheet(sheetName);\n  valueOptionsWorksheet.columns = Object.keys(valueOptionsData).map(key => ({\n    key\n  }));\n  Object.entries(valueOptionsData).forEach(([field, {\n    values\n  }]) => {\n    valueOptionsWorksheet.getColumn(field).values = values;\n  });\n}\nexport async function buildExcel(options, api) {\n  const {\n    columns,\n    rowIds,\n    includeHeaders,\n    includeColumnGroupsHeaders,\n    valueOptionsSheetName = 'Options',\n    exceljsPreProcess,\n    exceljsPostProcess,\n    columnsStyles = {}\n  } = options;\n  const excelJS = await getExcelJs();\n  const workbook = new excelJS.Workbook();\n  const worksheet = workbook.addWorksheet('Sheet1');\n  const serializedColumns = serializeColumns(columns, columnsStyles);\n  worksheet.columns = serializedColumns;\n  if (exceljsPreProcess) {\n    await exceljsPreProcess({\n      workbook,\n      worksheet\n    });\n  }\n  if (includeColumnGroupsHeaders) {\n    const columnGroupPaths = columns.reduce((acc, column) => {\n      acc[column.field] = api.unstable_getColumnGroupPath(column.field);\n      return acc;\n    }, {});\n    addColumnGroupingHeaders(worksheet, serializedColumns, columnGroupPaths, api.unstable_getAllGroupDetails());\n  }\n  if (includeHeaders) {\n    worksheet.addRow(columns.map(column => {\n      var _column$headerName3;\n      return (_column$headerName3 = column.headerName) != null ? _column$headerName3 : column.field;\n    }));\n  }\n  const valueOptionsData = await getDataForValueOptionsSheet(columns, valueOptionsSheetName, api);\n  createValueOptionsSheetIfNeeded(valueOptionsData, valueOptionsSheetName, workbook);\n  rowIds.forEach(id => {\n    const serializedRow = serializeRow(id, columns, api, valueOptionsData);\n    addSerializedRowToWorksheet(serializedRow, worksheet);\n  });\n  if (exceljsPostProcess) {\n    await exceljsPostProcess({\n      workbook,\n      worksheet\n    });\n  }\n  return workbook;\n}\nexport function setupExcelExportWebWorker(workerOptions = {}) {\n  // eslint-disable-next-line no-restricted-globals\n  addEventListener('message', async event => {\n    var _options$includeHeade;\n    const {\n      serializedColumns,\n      serializedRows,\n      options,\n      valueOptionsSheetName,\n      valueOptionsData,\n      columnGroupDetails,\n      columnGroupPaths\n    } = event.data;\n    const {\n      exceljsPostProcess,\n      exceljsPreProcess\n    } = workerOptions;\n    const excelJS = await getExcelJs();\n    const workbook = new excelJS.Workbook();\n    const worksheet = workbook.addWorksheet('Sheet1');\n    worksheet.columns = serializedColumns;\n    if (exceljsPreProcess) {\n      await exceljsPreProcess({\n        workbook,\n        worksheet\n      });\n    }\n    if (options.includeColumnGroupsHeaders) {\n      addColumnGroupingHeaders(worksheet, serializedColumns, columnGroupPaths, columnGroupDetails);\n    }\n    const includeHeaders = (_options$includeHeade = options.includeHeaders) != null ? _options$includeHeade : true;\n    if (includeHeaders) {\n      worksheet.addRow(serializedColumns.map(column => column.headerText));\n    }\n    createValueOptionsSheetIfNeeded(valueOptionsData, valueOptionsSheetName, workbook);\n    serializedRows.forEach(serializedRow => {\n      addSerializedRowToWorksheet(serializedRow, worksheet);\n    });\n    if (exceljsPostProcess) {\n      await exceljsPostProcess({\n        workbook,\n        worksheet\n      });\n    }\n    postMessage(await workbook.xlsx.writeBuffer());\n  });\n}","map":{"version":3,"names":["_extends","GRID_DATE_COL_DEF","GRID_DATETIME_COL_DEF","buildWarning","isObject","isSingleSelectColDef","getExcelJs","_excelJsModule$defaul","excelJsModule","default","warnInvalidFormattedValue","getFormattedValueOptions","colDef","valueOptions","api","valueOptionsFormatted","valueFormatter","map","option","params","field","value","String","label","serializeRow","id","columns","defaultValueOptionsFormulae","row","dataValidation","mergedCells","firstCellParams","getCellParams","outlineLevel","rowNode","depth","calculateColSpan","rowId","minFirstColumn","maxLastColumn","length","forEach","column","colIndex","colSpanInfo","unstable_getCellColSpanInfo","spannedByColSpan","cellProps","colSpan","push","leftIndex","rightIndex","cellParams","type","castColumn","formattedValueOptions","allowBlank","formulae","x","toString","replaceAll","join","address","formattedValue","process","env","NODE_ENV","utcDate","Date","UTC","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","defaultColumnsStyles","numFmt","serializeColumn","columnsStyles","_column$headerName","key","headerText","headerName","width","Math","min","style","addColumnGroupingHeaders","worksheet","columnGroupPaths","columnGroupDetails","maxDepth","max","_columnGroupPaths$key","_columnGroupPaths$key2","rowIndex","groupingPath","groupId","parents","slice","newRow","addRow","group","_group$headerName","lastRowIndex","rowCount","leftGroupId","leftParents","rightGroupId","rightParents","areInSameGroup","every","leftParent","index","mergeCells","serializeColumns","styles","getDataForValueOptionsSheet","valueOptionsSheetName","candidateColumns","filter","Array","isArray","excelJS","workbook","Workbook","addWorksheet","reduce","acc","_column$headerName2","singleSelectColumn","header","values","letter","getColumn","addSerializedRowToWorksheet","serializedRow","Object","keys","getCell","mergedCell","createValueOptionsSheetIfNeeded","valueOptionsData","sheetName","valueOptionsWorksheet","entries","buildExcel","options","rowIds","includeHeaders","includeColumnGroupsHeaders","exceljsPreProcess","exceljsPostProcess","serializedColumns","unstable_getColumnGroupPath","unstable_getAllGroupDetails","_column$headerName3","setupExcelExportWebWorker","workerOptions","addEventListener","event","_options$includeHeade","serializedRows","data","postMessage","xlsx","writeBuffer"],"sources":["/Users/shyamkansagra/Documents/Code/general/pocket-wallet/node_modules/@mui/x-data-grid-premium/hooks/features/export/serializer/excelSerializer.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GRID_DATE_COL_DEF, GRID_DATETIME_COL_DEF } from '@mui/x-data-grid-pro';\nimport { buildWarning, isObject, isSingleSelectColDef } from '@mui/x-data-grid/internals';\nconst getExcelJs = async () => {\n  var _excelJsModule$defaul;\n  const excelJsModule = await import('exceljs');\n  return (_excelJsModule$defaul = excelJsModule.default) != null ? _excelJsModule$defaul : excelJsModule;\n};\nconst warnInvalidFormattedValue = buildWarning(['MUI: When the value of a field is an object or a `renderCell` is provided, the Excel export might not display the value correctly.', 'You can provide a `valueFormatter` with a string representation to be used.']);\nconst getFormattedValueOptions = (colDef, valueOptions, api) => {\n  if (!colDef.valueOptions) {\n    return [];\n  }\n  let valueOptionsFormatted = valueOptions;\n  if (colDef.valueFormatter) {\n    valueOptionsFormatted = valueOptionsFormatted.map(option => {\n      if (typeof option === 'object') {\n        return option;\n      }\n      const params = {\n        field: colDef.field,\n        api,\n        value: option\n      };\n      return String(colDef.valueFormatter(params));\n    });\n  }\n  return valueOptionsFormatted.map(option => typeof option === 'object' ? option.label : option);\n};\nexport const serializeRow = (id, columns, api, defaultValueOptionsFormulae) => {\n  const row = {};\n  const dataValidation = {};\n  const mergedCells = [];\n  const firstCellParams = api.getCellParams(id, columns[0].field);\n  const outlineLevel = firstCellParams.rowNode.depth;\n\n  // `colSpan` is only calculated for rendered rows, so we need to calculate it during export for every row\n  api.calculateColSpan({\n    rowId: id,\n    minFirstColumn: 0,\n    maxLastColumn: columns.length,\n    columns\n  });\n  columns.forEach((column, colIndex) => {\n    const colSpanInfo = api.unstable_getCellColSpanInfo(id, colIndex);\n    if (colSpanInfo && colSpanInfo.spannedByColSpan) {\n      return;\n    }\n    if (colSpanInfo && colSpanInfo.cellProps.colSpan > 1) {\n      mergedCells.push({\n        leftIndex: colIndex + 1,\n        rightIndex: colIndex + colSpanInfo.cellProps.colSpan\n      });\n    }\n    const cellParams = api.getCellParams(id, column.field);\n    switch (cellParams.colDef.type) {\n      case 'singleSelect':\n        {\n          const castColumn = cellParams.colDef;\n          if (typeof castColumn.valueOptions === 'function') {\n            // If value option depends on the row, set specific options to the cell\n            // This dataValidation is buggy with LibreOffice and does not allow to have coma\n            const valueOptions = castColumn.valueOptions({\n              id,\n              row,\n              field: cellParams.field\n            });\n            const formattedValueOptions = getFormattedValueOptions(castColumn, valueOptions, api);\n            dataValidation[castColumn.field] = {\n              type: 'list',\n              allowBlank: true,\n              formulae: [`\"${formattedValueOptions.map(x => x.toString().replaceAll(',', 'CHAR(44)')).join(',')}\"`]\n            };\n          } else {\n            const address = defaultValueOptionsFormulae[column.field].address;\n\n            // If value option is defined for the column, refer to another sheet\n            dataValidation[castColumn.field] = {\n              type: 'list',\n              allowBlank: true,\n              formulae: [address]\n            };\n          }\n          const formattedValue = api.getCellParams(id, castColumn.field).formattedValue;\n          if (process.env.NODE_ENV !== 'production') {\n            if (String(cellParams.formattedValue) === '[object Object]') {\n              warnInvalidFormattedValue();\n            }\n          }\n          if (isObject(formattedValue)) {\n            row[castColumn.field] = formattedValue == null ? void 0 : formattedValue.label;\n          } else {\n            row[castColumn.field] = formattedValue;\n          }\n          break;\n        }\n      case 'boolean':\n      case 'number':\n        row[column.field] = api.getCellParams(id, column.field).value;\n        break;\n      case 'date':\n      case 'dateTime':\n        {\n          // Excel does not do any timezone conversion, so we create a date using UTC instead of local timezone\n          // Solution from: https://github.com/exceljs/exceljs/issues/486#issuecomment-432557582\n          // About Date.UTC(): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/UTC#exemples\n          const value = api.getCellParams(id, column.field).value;\n          // value may be `undefined` in auto-generated grouping rows\n          if (!value) {\n            break;\n          }\n          const utcDate = new Date(Date.UTC(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds()));\n          row[column.field] = utcDate;\n          break;\n        }\n      case 'actions':\n        break;\n      default:\n        row[column.field] = api.getCellParams(id, column.field).formattedValue;\n        if (process.env.NODE_ENV !== 'production') {\n          if (String(cellParams.formattedValue) === '[object Object]') {\n            warnInvalidFormattedValue();\n          }\n        }\n        break;\n    }\n  });\n  return {\n    row,\n    dataValidation,\n    outlineLevel,\n    mergedCells\n  };\n};\nconst defaultColumnsStyles = {\n  [GRID_DATE_COL_DEF.type]: {\n    numFmt: 'dd.mm.yyyy'\n  },\n  [GRID_DATETIME_COL_DEF.type]: {\n    numFmt: 'dd.mm.yyyy hh:mm'\n  }\n};\nexport const serializeColumn = (column, columnsStyles) => {\n  var _column$headerName;\n  const {\n    field,\n    type\n  } = column;\n  return {\n    key: field,\n    headerText: (_column$headerName = column.headerName) != null ? _column$headerName : column.field,\n    // Excel width must stay between 0 and 255 (https://support.microsoft.com/en-us/office/change-the-column-width-and-row-height-72f5e3cc-994d-43e8-ae58-9774a0905f46)\n    // From the example of column width behavior (https://docs.microsoft.com/en-US/office/troubleshoot/excel/determine-column-widths#example-of-column-width-behavior)\n    // a value of 10 corresponds to 75px. This is an approximation, because column width depends on the font-size\n    width: Math.min(255, column.width ? column.width / 7.5 : 8.43),\n    style: _extends({}, type && (defaultColumnsStyles == null ? void 0 : defaultColumnsStyles[type]), columnsStyles == null ? void 0 : columnsStyles[field])\n  };\n};\nconst addColumnGroupingHeaders = (worksheet, columns, columnGroupPaths, columnGroupDetails) => {\n  const maxDepth = Math.max(...columns.map(({\n    key\n  }) => {\n    var _columnGroupPaths$key, _columnGroupPaths$key2;\n    return (_columnGroupPaths$key = (_columnGroupPaths$key2 = columnGroupPaths[key]) == null ? void 0 : _columnGroupPaths$key2.length) != null ? _columnGroupPaths$key : 0;\n  }));\n  if (maxDepth === 0) {\n    return;\n  }\n  for (let rowIndex = 0; rowIndex < maxDepth; rowIndex += 1) {\n    const row = columns.map(({\n      key\n    }) => {\n      const groupingPath = columnGroupPaths[key];\n      if (groupingPath.length <= rowIndex) {\n        return {\n          groupId: null,\n          parents: groupingPath\n        };\n      }\n      return _extends({}, columnGroupDetails[groupingPath[rowIndex]], {\n        parents: groupingPath.slice(0, rowIndex)\n      });\n    });\n    const newRow = worksheet.addRow(row.map(group => {\n      var _group$headerName;\n      return group.groupId === null ? null : (_group$headerName = group == null ? void 0 : group.headerName) != null ? _group$headerName : group.groupId;\n    }));\n\n    // use `rowCount`, since worksheet can have additional rows added in `exceljsPreProcess`\n    const lastRowIndex = newRow.worksheet.rowCount;\n    let leftIndex = 0;\n    let rightIndex = 1;\n    while (rightIndex < columns.length) {\n      const {\n        groupId: leftGroupId,\n        parents: leftParents\n      } = row[leftIndex];\n      const {\n        groupId: rightGroupId,\n        parents: rightParents\n      } = row[rightIndex];\n      const areInSameGroup = leftGroupId === rightGroupId && leftParents.length === rightParents.length && leftParents.every((leftParent, index) => rightParents[index] === leftParent);\n      if (areInSameGroup) {\n        rightIndex += 1;\n      } else {\n        if (rightIndex - leftIndex > 1) {\n          worksheet.mergeCells(lastRowIndex, leftIndex + 1, lastRowIndex, rightIndex);\n        }\n        leftIndex = rightIndex;\n        rightIndex += 1;\n      }\n    }\n    if (rightIndex - leftIndex > 1) {\n      worksheet.mergeCells(lastRowIndex, leftIndex + 1, lastRowIndex, rightIndex);\n    }\n  }\n};\nexport function serializeColumns(columns, styles) {\n  return columns.map(column => serializeColumn(column, styles));\n}\nexport async function getDataForValueOptionsSheet(columns, valueOptionsSheetName, api) {\n  const candidateColumns = columns.filter(column => isSingleSelectColDef(column) && Array.isArray(column.valueOptions));\n\n  // Creates a temp worksheet to obtain the column letters\n  const excelJS = await getExcelJs();\n  const workbook = new excelJS.Workbook();\n  const worksheet = workbook.addWorksheet('Sheet1');\n  worksheet.columns = candidateColumns.map(column => ({\n    key: column.field\n  }));\n  return candidateColumns.reduce((acc, column) => {\n    var _column$headerName2;\n    const singleSelectColumn = column;\n    const formattedValueOptions = getFormattedValueOptions(singleSelectColumn, singleSelectColumn.valueOptions, api);\n    const header = (_column$headerName2 = column.headerName) != null ? _column$headerName2 : column.field;\n    const values = [header, ...formattedValueOptions];\n    const letter = worksheet.getColumn(column.field).letter;\n    const address = `${valueOptionsSheetName}!$${letter}$2:$${letter}$${values.length}`;\n    acc[column.field] = {\n      values,\n      address\n    };\n    return acc;\n  }, {});\n}\nfunction addSerializedRowToWorksheet(serializedRow, worksheet) {\n  const {\n    row,\n    dataValidation,\n    outlineLevel,\n    mergedCells\n  } = serializedRow;\n  const newRow = worksheet.addRow(row);\n  Object.keys(dataValidation).forEach(field => {\n    newRow.getCell(field).dataValidation = _extends({}, dataValidation[field]);\n  });\n  if (outlineLevel) {\n    newRow.outlineLevel = outlineLevel;\n  }\n\n  // use `rowCount`, since worksheet can have additional rows added in `exceljsPreProcess`\n  const lastRowIndex = newRow.worksheet.rowCount;\n  mergedCells.forEach(mergedCell => {\n    worksheet.mergeCells(lastRowIndex, mergedCell.leftIndex, lastRowIndex, mergedCell.rightIndex);\n  });\n}\nasync function createValueOptionsSheetIfNeeded(valueOptionsData, sheetName, workbook) {\n  if (Object.keys(valueOptionsData).length === 0) {\n    return;\n  }\n  const valueOptionsWorksheet = workbook.addWorksheet(sheetName);\n  valueOptionsWorksheet.columns = Object.keys(valueOptionsData).map(key => ({\n    key\n  }));\n  Object.entries(valueOptionsData).forEach(([field, {\n    values\n  }]) => {\n    valueOptionsWorksheet.getColumn(field).values = values;\n  });\n}\nexport async function buildExcel(options, api) {\n  const {\n    columns,\n    rowIds,\n    includeHeaders,\n    includeColumnGroupsHeaders,\n    valueOptionsSheetName = 'Options',\n    exceljsPreProcess,\n    exceljsPostProcess,\n    columnsStyles = {}\n  } = options;\n  const excelJS = await getExcelJs();\n  const workbook = new excelJS.Workbook();\n  const worksheet = workbook.addWorksheet('Sheet1');\n  const serializedColumns = serializeColumns(columns, columnsStyles);\n  worksheet.columns = serializedColumns;\n  if (exceljsPreProcess) {\n    await exceljsPreProcess({\n      workbook,\n      worksheet\n    });\n  }\n  if (includeColumnGroupsHeaders) {\n    const columnGroupPaths = columns.reduce((acc, column) => {\n      acc[column.field] = api.unstable_getColumnGroupPath(column.field);\n      return acc;\n    }, {});\n    addColumnGroupingHeaders(worksheet, serializedColumns, columnGroupPaths, api.unstable_getAllGroupDetails());\n  }\n  if (includeHeaders) {\n    worksheet.addRow(columns.map(column => {\n      var _column$headerName3;\n      return (_column$headerName3 = column.headerName) != null ? _column$headerName3 : column.field;\n    }));\n  }\n  const valueOptionsData = await getDataForValueOptionsSheet(columns, valueOptionsSheetName, api);\n  createValueOptionsSheetIfNeeded(valueOptionsData, valueOptionsSheetName, workbook);\n  rowIds.forEach(id => {\n    const serializedRow = serializeRow(id, columns, api, valueOptionsData);\n    addSerializedRowToWorksheet(serializedRow, worksheet);\n  });\n  if (exceljsPostProcess) {\n    await exceljsPostProcess({\n      workbook,\n      worksheet\n    });\n  }\n  return workbook;\n}\nexport function setupExcelExportWebWorker(workerOptions = {}) {\n  // eslint-disable-next-line no-restricted-globals\n  addEventListener('message', async event => {\n    var _options$includeHeade;\n    const {\n      serializedColumns,\n      serializedRows,\n      options,\n      valueOptionsSheetName,\n      valueOptionsData,\n      columnGroupDetails,\n      columnGroupPaths\n    } = event.data;\n    const {\n      exceljsPostProcess,\n      exceljsPreProcess\n    } = workerOptions;\n    const excelJS = await getExcelJs();\n    const workbook = new excelJS.Workbook();\n    const worksheet = workbook.addWorksheet('Sheet1');\n    worksheet.columns = serializedColumns;\n    if (exceljsPreProcess) {\n      await exceljsPreProcess({\n        workbook,\n        worksheet\n      });\n    }\n    if (options.includeColumnGroupsHeaders) {\n      addColumnGroupingHeaders(worksheet, serializedColumns, columnGroupPaths, columnGroupDetails);\n    }\n    const includeHeaders = (_options$includeHeade = options.includeHeaders) != null ? _options$includeHeade : true;\n    if (includeHeaders) {\n      worksheet.addRow(serializedColumns.map(column => column.headerText));\n    }\n    createValueOptionsSheetIfNeeded(valueOptionsData, valueOptionsSheetName, workbook);\n    serializedRows.forEach(serializedRow => {\n      addSerializedRowToWorksheet(serializedRow, worksheet);\n    });\n    if (exceljsPostProcess) {\n      await exceljsPostProcess({\n        workbook,\n        worksheet\n      });\n    }\n    postMessage(await workbook.xlsx.writeBuffer());\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}