{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nexport const getGroupRowIdFromPath = path => {\n  const pathStr = path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).join('-');\n  return `auto-generated-row-${pathStr}`;\n};\nexport const getNodePathInTree = ({\n  id,\n  tree\n}) => {\n  const path = [];\n  let node = tree[id];\n  while (node.id !== GRID_ROOT_GROUP_ID) {\n    path.push({\n      field: node.type === 'leaf' ? null : node.groupingField,\n      key: node.groupingKey\n    });\n    node = tree[node.parent];\n  }\n  path.reverse();\n  return path;\n};\nexport const updateGroupDefaultExpansion = (node, defaultGroupingExpansionDepth, isGroupExpandedByDefault) => {\n  let childrenExpanded;\n  if (node.id === GRID_ROOT_GROUP_ID) {\n    childrenExpanded = true;\n  } else if (isGroupExpandedByDefault) {\n    childrenExpanded = isGroupExpandedByDefault(node);\n  } else {\n    childrenExpanded = defaultGroupingExpansionDepth === -1 || defaultGroupingExpansionDepth > node.depth;\n  }\n  node.childrenExpanded = childrenExpanded;\n  return node;\n};\n\n/**\n * Insert a node in the tree\n */\nexport const insertNodeInTree = (node, tree, treeDepths, previousTree) => {\n  var _treeDepths$node$dept;\n  // 1. Insert node in the tree.\n  tree[node.id] = node;\n\n  // 2. Increment the `treeDepths` object for the node's depth.\n  treeDepths[node.depth] = ((_treeDepths$node$dept = treeDepths[node.depth]) != null ? _treeDepths$node$dept : 0) + 1;\n\n  // 3. Register the new node in its parent.\n  const parentNode = tree[node.parent];\n  if (node.type === 'group' || node.type === 'leaf') {\n    var _groupingField, _groupingKey, _parentNode$childrenF;\n    // For groups and leaves,\n    // Register the node from its parents `children` and `childrenFromPath` properties.\n    const groupingFieldName = (_groupingField = node.groupingField) != null ? _groupingField : '__no_field__';\n    const groupingKeyName = (_groupingKey = node.groupingKey) != null ? _groupingKey : '__no_key__';\n    const groupingField = (_parentNode$childrenF = parentNode.childrenFromPath) == null ? void 0 : _parentNode$childrenF[groupingFieldName];\n    if (previousTree !== null && previousTree[parentNode.id] === tree[parentNode.id]) {\n      parentNode.children = [...parentNode.children, node.id];\n    } else {\n      parentNode.children.push(node.id);\n    }\n    if (groupingField == null) {\n      parentNode.childrenFromPath[groupingFieldName] = {\n        [groupingKeyName.toString()]: node.id\n      };\n    } else {\n      groupingField[groupingKeyName.toString()] = node.id;\n    }\n  } else if (node.type === 'footer') {\n    // For footers,\n    // Register the node from its parent `footerId` property.\n    parentNode.footerId = node.id;\n  }\n};\n\n/**\n * Removes a node from the tree\n */\nexport const removeNodeFromTree = ({\n  node,\n  tree,\n  treeDepths\n}) => {\n  // 1. Remove node from the tree.\n  delete tree[node.id];\n\n  // 2. Decrement the `treeDepths` object for the node's depth.\n  const nodeDepth = node.depth;\n  const currentNodeCount = treeDepths[nodeDepth];\n  if (currentNodeCount === 1) {\n    delete treeDepths[nodeDepth];\n  } else {\n    treeDepths[nodeDepth] = currentNodeCount - 1;\n  }\n\n  // 3. Unregister the new node in its parent.\n  const parentNode = tree[node.parent];\n  // For footers,\n  // Unregister the node from its parent `footerId` property.\n  if (node.type === 'footer') {\n    tree[parentNode.id] = _extends({}, parentNode, {\n      footerId: null\n    });\n  }\n  // For groups and leaves,\n  // Unregister the node from its parents `children` and `childrenFromPath` properties.\n  else {\n    var _groupingField2, _groupingKey2;\n    const groupingField = (_groupingField2 = node.groupingField) != null ? _groupingField2 : '__no_field__';\n    const groupingKey = (_groupingKey2 = node.groupingKey) != null ? _groupingKey2 : '__no_key__';\n\n    // TODO rows v6: Can we avoid this linear complexity ?\n    const children = parentNode.children.filter(childId => childId !== node.id);\n    const childrenFromPath = parentNode.childrenFromPath;\n    delete childrenFromPath[groupingField][groupingKey.toString()];\n    tree[parentNode.id] = _extends({}, parentNode, {\n      children,\n      childrenFromPath\n    });\n  }\n};\n\n/**\n * Updates the `id` and `isAutoGenerated` properties of a group node.\n */\nexport const updateGroupNodeIdAndAutoGenerated = ({\n  node,\n  updatedNode,\n  previousTree,\n  tree,\n  treeDepths\n}) => {\n  // 1. Set the new parent for all children from the old group\n  node.children.forEach(childId => {\n    tree[childId] = _extends({}, tree[childId], {\n      parent: updatedNode.id\n    });\n  });\n\n  // 2. Remove the old group from the tree\n  removeNodeFromTree({\n    node,\n    tree,\n    treeDepths\n  });\n\n  // 3. Add the new group in the tree\n  const groupNode = _extends({}, node, updatedNode);\n  insertNodeInTree(groupNode, tree, treeDepths, previousTree);\n};\nexport const createUpdatedGroupsManager = () => ({\n  value: {},\n  addAction(groupId, action) {\n    if (!this.value[groupId]) {\n      this.value[groupId] = {};\n    }\n    this.value[groupId][action] = true;\n  }\n});\nexport const getVisibleRowsLookup = ({\n  tree,\n  filteredRowsLookup\n}) => {\n  if (!filteredRowsLookup) {\n    return {};\n  }\n  const visibleRowsLookup = {};\n  const handleTreeNode = (node, areAncestorsExpanded) => {\n    const isPassingFiltering = filteredRowsLookup[node.id];\n    if (node.type === 'group') {\n      node.children.forEach(childId => {\n        const childNode = tree[childId];\n        handleTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded);\n      });\n    }\n    visibleRowsLookup[node.id] = isPassingFiltering && areAncestorsExpanded;\n\n    // TODO rows v6: Should we keep storing the visibility status of footer independently or rely on the group visibility in the selector ?\n    if (node.type === 'group' && node.footerId != null) {\n      visibleRowsLookup[node.footerId] = isPassingFiltering && areAncestorsExpanded && !!node.childrenExpanded;\n    }\n  };\n  const nodes = Object.values(tree);\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n    if (node.depth === 0) {\n      handleTreeNode(node, true);\n    }\n  }\n  return visibleRowsLookup;\n};","map":{"version":3,"names":["_extends","GRID_ROOT_GROUP_ID","getGroupRowIdFromPath","path","pathStr","map","groupingCriteria","field","key","join","getNodePathInTree","id","tree","node","push","type","groupingField","groupingKey","parent","reverse","updateGroupDefaultExpansion","defaultGroupingExpansionDepth","isGroupExpandedByDefault","childrenExpanded","depth","insertNodeInTree","treeDepths","previousTree","_treeDepths$node$dept","parentNode","_groupingField","_groupingKey","_parentNode$childrenF","groupingFieldName","groupingKeyName","childrenFromPath","children","toString","footerId","removeNodeFromTree","nodeDepth","currentNodeCount","_groupingField2","_groupingKey2","filter","childId","updateGroupNodeIdAndAutoGenerated","updatedNode","forEach","groupNode","createUpdatedGroupsManager","value","addAction","groupId","action","getVisibleRowsLookup","filteredRowsLookup","visibleRowsLookup","handleTreeNode","areAncestorsExpanded","isPassingFiltering","childNode","nodes","Object","values","i","length"],"sources":["/Users/shyamkansagra/Documents/Code/general/pocket-wallet/node_modules/@mui/x-data-grid-pro/utils/tree/utils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nexport const getGroupRowIdFromPath = path => {\n  const pathStr = path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).join('-');\n  return `auto-generated-row-${pathStr}`;\n};\nexport const getNodePathInTree = ({\n  id,\n  tree\n}) => {\n  const path = [];\n  let node = tree[id];\n  while (node.id !== GRID_ROOT_GROUP_ID) {\n    path.push({\n      field: node.type === 'leaf' ? null : node.groupingField,\n      key: node.groupingKey\n    });\n    node = tree[node.parent];\n  }\n  path.reverse();\n  return path;\n};\nexport const updateGroupDefaultExpansion = (node, defaultGroupingExpansionDepth, isGroupExpandedByDefault) => {\n  let childrenExpanded;\n  if (node.id === GRID_ROOT_GROUP_ID) {\n    childrenExpanded = true;\n  } else if (isGroupExpandedByDefault) {\n    childrenExpanded = isGroupExpandedByDefault(node);\n  } else {\n    childrenExpanded = defaultGroupingExpansionDepth === -1 || defaultGroupingExpansionDepth > node.depth;\n  }\n  node.childrenExpanded = childrenExpanded;\n  return node;\n};\n\n/**\n * Insert a node in the tree\n */\nexport const insertNodeInTree = (node, tree, treeDepths, previousTree) => {\n  var _treeDepths$node$dept;\n  // 1. Insert node in the tree.\n  tree[node.id] = node;\n\n  // 2. Increment the `treeDepths` object for the node's depth.\n  treeDepths[node.depth] = ((_treeDepths$node$dept = treeDepths[node.depth]) != null ? _treeDepths$node$dept : 0) + 1;\n\n  // 3. Register the new node in its parent.\n  const parentNode = tree[node.parent];\n  if (node.type === 'group' || node.type === 'leaf') {\n    var _groupingField, _groupingKey, _parentNode$childrenF;\n    // For groups and leaves,\n    // Register the node from its parents `children` and `childrenFromPath` properties.\n    const groupingFieldName = (_groupingField = node.groupingField) != null ? _groupingField : '__no_field__';\n    const groupingKeyName = (_groupingKey = node.groupingKey) != null ? _groupingKey : '__no_key__';\n    const groupingField = (_parentNode$childrenF = parentNode.childrenFromPath) == null ? void 0 : _parentNode$childrenF[groupingFieldName];\n    if (previousTree !== null && previousTree[parentNode.id] === tree[parentNode.id]) {\n      parentNode.children = [...parentNode.children, node.id];\n    } else {\n      parentNode.children.push(node.id);\n    }\n    if (groupingField == null) {\n      parentNode.childrenFromPath[groupingFieldName] = {\n        [groupingKeyName.toString()]: node.id\n      };\n    } else {\n      groupingField[groupingKeyName.toString()] = node.id;\n    }\n  } else if (node.type === 'footer') {\n    // For footers,\n    // Register the node from its parent `footerId` property.\n    parentNode.footerId = node.id;\n  }\n};\n\n/**\n * Removes a node from the tree\n */\nexport const removeNodeFromTree = ({\n  node,\n  tree,\n  treeDepths\n}) => {\n  // 1. Remove node from the tree.\n  delete tree[node.id];\n\n  // 2. Decrement the `treeDepths` object for the node's depth.\n  const nodeDepth = node.depth;\n  const currentNodeCount = treeDepths[nodeDepth];\n  if (currentNodeCount === 1) {\n    delete treeDepths[nodeDepth];\n  } else {\n    treeDepths[nodeDepth] = currentNodeCount - 1;\n  }\n\n  // 3. Unregister the new node in its parent.\n  const parentNode = tree[node.parent];\n  // For footers,\n  // Unregister the node from its parent `footerId` property.\n  if (node.type === 'footer') {\n    tree[parentNode.id] = _extends({}, parentNode, {\n      footerId: null\n    });\n  }\n  // For groups and leaves,\n  // Unregister the node from its parents `children` and `childrenFromPath` properties.\n  else {\n    var _groupingField2, _groupingKey2;\n    const groupingField = (_groupingField2 = node.groupingField) != null ? _groupingField2 : '__no_field__';\n    const groupingKey = (_groupingKey2 = node.groupingKey) != null ? _groupingKey2 : '__no_key__';\n\n    // TODO rows v6: Can we avoid this linear complexity ?\n    const children = parentNode.children.filter(childId => childId !== node.id);\n    const childrenFromPath = parentNode.childrenFromPath;\n    delete childrenFromPath[groupingField][groupingKey.toString()];\n    tree[parentNode.id] = _extends({}, parentNode, {\n      children,\n      childrenFromPath\n    });\n  }\n};\n\n/**\n * Updates the `id` and `isAutoGenerated` properties of a group node.\n */\nexport const updateGroupNodeIdAndAutoGenerated = ({\n  node,\n  updatedNode,\n  previousTree,\n  tree,\n  treeDepths\n}) => {\n  // 1. Set the new parent for all children from the old group\n  node.children.forEach(childId => {\n    tree[childId] = _extends({}, tree[childId], {\n      parent: updatedNode.id\n    });\n  });\n\n  // 2. Remove the old group from the tree\n  removeNodeFromTree({\n    node,\n    tree,\n    treeDepths\n  });\n\n  // 3. Add the new group in the tree\n  const groupNode = _extends({}, node, updatedNode);\n  insertNodeInTree(groupNode, tree, treeDepths, previousTree);\n};\nexport const createUpdatedGroupsManager = () => ({\n  value: {},\n  addAction(groupId, action) {\n    if (!this.value[groupId]) {\n      this.value[groupId] = {};\n    }\n    this.value[groupId][action] = true;\n  }\n});\nexport const getVisibleRowsLookup = ({\n  tree,\n  filteredRowsLookup\n}) => {\n  if (!filteredRowsLookup) {\n    return {};\n  }\n  const visibleRowsLookup = {};\n  const handleTreeNode = (node, areAncestorsExpanded) => {\n    const isPassingFiltering = filteredRowsLookup[node.id];\n    if (node.type === 'group') {\n      node.children.forEach(childId => {\n        const childNode = tree[childId];\n        handleTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded);\n      });\n    }\n    visibleRowsLookup[node.id] = isPassingFiltering && areAncestorsExpanded;\n\n    // TODO rows v6: Should we keep storing the visibility status of footer independently or rely on the group visibility in the selector ?\n    if (node.type === 'group' && node.footerId != null) {\n      visibleRowsLookup[node.footerId] = isPassingFiltering && areAncestorsExpanded && !!node.childrenExpanded;\n    }\n  };\n  const nodes = Object.values(tree);\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n    if (node.depth === 0) {\n      handleTreeNode(node, true);\n    }\n  }\n  return visibleRowsLookup;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}