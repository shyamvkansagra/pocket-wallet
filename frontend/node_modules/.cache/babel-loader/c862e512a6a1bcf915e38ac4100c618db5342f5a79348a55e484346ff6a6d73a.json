{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"],\n  _excluded2 = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"];\nimport * as React from 'react';\nimport { GRID_STRING_COL_DEF } from '@mui/x-data-grid-pro';\nimport { isSingleSelectColDef } from '@mui/x-data-grid-pro/internals';\nimport { GridGroupingColumnFooterCell } from '../../../components/GridGroupingColumnFooterCell';\nimport { GridGroupingCriteriaCell } from '../../../components/GridGroupingCriteriaCell';\nimport { GridGroupingColumnLeafCell } from '../../../components/GridGroupingColumnLeafCell';\nimport { getRowGroupingFieldFromGroupingCriteria, GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD } from './gridRowGroupingUtils';\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst GROUPING_COL_DEF_DEFAULT_PROPERTIES = _extends({}, GRID_STRING_COL_DEF, {\n  disableReorder: true\n});\nconst GROUPING_COL_DEF_FORCED_PROPERTIES = {\n  type: 'rowGroupByColumnsGroup',\n  editable: false,\n  groupable: false\n};\n\n/**\n * When sorting two cells with different grouping criteria, we consider that the cell with the grouping criteria coming first in the model should be displayed below.\n * This can occur when some rows don't have all the fields. In which case we want the rows with the missing field to be displayed above.\n * TODO: Make this index comparator depth invariant, the logic should not be inverted when sorting in the \"desc\" direction (but the current return format of `sortComparator` does not support this behavior).\n */\nconst groupingFieldIndexComparator = (v1, v2, cellParams1, cellParams2) => {\n  var _groupingField, _groupingField2;\n  const model = gridRowGroupingSanitizedModelSelector(cellParams1.api.state, cellParams1.api.instanceId);\n  const groupingField1 = (_groupingField = cellParams1.rowNode.groupingField) != null ? _groupingField : null;\n  const groupingField2 = (_groupingField2 = cellParams2.rowNode.groupingField) != null ? _groupingField2 : null;\n  if (groupingField1 === groupingField2) {\n    return 0;\n  }\n  if (groupingField1 == null) {\n    return -1;\n  }\n  if (groupingField2 == null) {\n    return 1;\n  }\n  if (model.indexOf(groupingField1) < model.indexOf(groupingField2)) {\n    return -1;\n  }\n  return 1;\n};\nconst getLeafProperties = leafColDef => {\n  var _leafColDef$headerNam;\n  return {\n    headerName: (_leafColDef$headerNam = leafColDef.headerName) != null ? _leafColDef$headerNam : leafColDef.field,\n    sortable: leafColDef.sortable,\n    filterable: leafColDef.filterable,\n    valueOptions: isSingleSelectColDef(leafColDef) ? leafColDef.valueOptions : undefined,\n    filterOperators: leafColDef.filterOperators,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the leaves\n      if (cellParams1.rowNode.type === 'leaf' && cellParams2.rowNode.type === 'leaf') {\n        return leafColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    }\n  };\n};\nconst getGroupingCriteriaProperties = (groupedByColDef, applyHeaderName) => {\n  const properties = {\n    sortable: groupedByColDef.sortable,\n    filterable: groupedByColDef.filterable,\n    valueOptions: isSingleSelectColDef(groupedByColDef) ? groupedByColDef.valueOptions : undefined,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the groups of the current grouping criteria\n      if (cellParams1.rowNode.type === 'group' && cellParams1.rowNode.groupingField === groupedByColDef.field && cellParams2.rowNode.type === 'group' && cellParams2.rowNode.groupingField === groupedByColDef.field) {\n        return groupedByColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    },\n    filterOperators: groupedByColDef.filterOperators\n  };\n  if (applyHeaderName) {\n    var _groupedByColDef$head;\n    properties.headerName = (_groupedByColDef$head = groupedByColDef.headerName) != null ? _groupedByColDef$head : groupedByColDef.field;\n  }\n  return properties;\n};\n/**\n * Creates the `GridColDef` for a grouping column that only takes care of a single grouping criteria\n */\nexport const createGroupingColDefForOneGroupingCriteria = ({\n  columnsLookup,\n  groupedByColDef,\n  groupingCriteria,\n  colDefOverride\n}) => {\n  var _groupedByColDef$widt, _leafColDef$width;\n  const _ref = colDefOverride != null ? colDefOverride : {},\n    {\n      leafField,\n      mainGroupingCriteria,\n      hideDescendantCount\n    } = _ref,\n    colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const leafColDef = leafField ? columnsLookup[leafField] : null;\n\n  // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n  const commonProperties = {\n    width: Math.max(((_groupedByColDef$widt = groupedByColDef.width) != null ? _groupedByColDef$widt : GRID_STRING_COL_DEF.width) + 40, (_leafColDef$width = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width : 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      }\n\n      // Render leaves\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n        return '';\n      }\n\n      // Render current grouping criteria groups\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n          hideDescendantCount: hideDescendantCount\n        }));\n      }\n      return '';\n    },\n    valueGetter: params => {\n      if (!params.rowNode || params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n        return undefined;\n      }\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return params.rowNode.groupingKey;\n      }\n      return undefined;\n    }\n  };\n\n  // If we have a `mainGroupingCriteria` defined and matching the `groupingCriteria`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedByColDef`.\n  // It can be useful to define a `leafField` for leaves rendering but still use the grouping criteria for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedColDef`.\n  let sourceProperties;\n  if (mainGroupingCriteria && mainGroupingCriteria === groupingCriteria) {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  }\n\n  // The properties that can't be overridden with `colDefOverride`\n  const forcedProperties = _extends({\n    field: getRowGroupingFieldFromGroupingCriteria(groupingCriteria)\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\n/**\n * Creates the `GridColDef` for a grouping column that takes care of all the grouping criteria\n */\nexport const createGroupingColDefForAllGroupingCriteria = ({\n  apiRef,\n  columnsLookup,\n  rowGroupingModel,\n  colDefOverride\n}) => {\n  var _leafColDef$width2;\n  const _ref2 = colDefOverride != null ? colDefOverride : {},\n    {\n      leafField,\n      mainGroupingCriteria,\n      hideDescendantCount\n    } = _ref2,\n    colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n  const leafColDef = leafField ? columnsLookup[leafField] : null;\n\n  // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n  const commonProperties = {\n    headerName: apiRef.current.getLocaleText('groupingColumnHeaderName'),\n    width: Math.max(...rowGroupingModel.map(field => {\n      var _columnsLookup$field$;\n      return ((_columnsLookup$field$ = columnsLookup[field].width) != null ? _columnsLookup$field$ : GRID_STRING_COL_DEF.width) + 40;\n    }), (_leafColDef$width2 = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width2 : 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      }\n\n      // Render the leaves\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n        return '';\n      }\n\n      // Render the groups\n      return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n        hideDescendantCount: hideDescendantCount\n      }));\n    },\n    valueGetter: params => {\n      if (!params.rowNode || params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n        return undefined;\n      }\n      return params.rowNode.groupingKey;\n    }\n  };\n\n  // If we have a `mainGroupingCriteria` defined and matching one of the `orderedGroupedByFields`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `columnsLookup[mainGroupingCriteria]`.\n  // It can be useful to use another grouping criteria than the top level one for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of the top level grouping criteria based on the properties of `columnsLookup[orderedGroupedByFields[0]]`.\n  let sourceProperties;\n  if (mainGroupingCriteria && rowGroupingModel.includes(mainGroupingCriteria)) {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[mainGroupingCriteria], true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[rowGroupingModel[0]], rowGroupingModel.length === 1);\n  }\n\n  // The properties that can't be overridden with `colDefOverride`\n  const forcedProperties = _extends({\n    field: GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};","map":{"version":3,"names":["_objectWithoutPropertiesLoose","_extends","_excluded","_excluded2","React","GRID_STRING_COL_DEF","isSingleSelectColDef","GridGroupingColumnFooterCell","GridGroupingCriteriaCell","GridGroupingColumnLeafCell","getRowGroupingFieldFromGroupingCriteria","GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD","gridRowGroupingSanitizedModelSelector","jsx","_jsx","GROUPING_COL_DEF_DEFAULT_PROPERTIES","disableReorder","GROUPING_COL_DEF_FORCED_PROPERTIES","type","editable","groupable","groupingFieldIndexComparator","v1","v2","cellParams1","cellParams2","_groupingField","_groupingField2","model","api","state","instanceId","groupingField1","rowNode","groupingField","groupingField2","indexOf","getLeafProperties","leafColDef","_leafColDef$headerNam","headerName","field","sortable","filterable","valueOptions","undefined","filterOperators","sortComparator","getGroupingCriteriaProperties","groupedByColDef","applyHeaderName","properties","_groupedByColDef$head","createGroupingColDefForOneGroupingCriteria","columnsLookup","groupingCriteria","colDefOverride","_groupedByColDef$widt","_leafColDef$width","_ref","leafField","mainGroupingCriteria","hideDescendantCount","colDefOverrideProperties","commonProperties","width","Math","max","renderCell","params","leafParams","getCellParams","id","hasFocus","valueGetter","getCellValue","groupingKey","sourceProperties","forcedProperties","createGroupingColDefForAllGroupingCriteria","apiRef","rowGroupingModel","_leafColDef$width2","_ref2","current","getLocaleText","map","_columnsLookup$field$","includes","length"],"sources":["/Users/shyamkansagra/Documents/Code/general/pocket-wallet/node_modules/@mui/x-data-grid-premium/hooks/features/rowGrouping/createGroupingColDef.js"],"sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"],\n  _excluded2 = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"];\nimport * as React from 'react';\nimport { GRID_STRING_COL_DEF } from '@mui/x-data-grid-pro';\nimport { isSingleSelectColDef } from '@mui/x-data-grid-pro/internals';\nimport { GridGroupingColumnFooterCell } from '../../../components/GridGroupingColumnFooterCell';\nimport { GridGroupingCriteriaCell } from '../../../components/GridGroupingCriteriaCell';\nimport { GridGroupingColumnLeafCell } from '../../../components/GridGroupingColumnLeafCell';\nimport { getRowGroupingFieldFromGroupingCriteria, GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD } from './gridRowGroupingUtils';\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst GROUPING_COL_DEF_DEFAULT_PROPERTIES = _extends({}, GRID_STRING_COL_DEF, {\n  disableReorder: true\n});\nconst GROUPING_COL_DEF_FORCED_PROPERTIES = {\n  type: 'rowGroupByColumnsGroup',\n  editable: false,\n  groupable: false\n};\n\n/**\n * When sorting two cells with different grouping criteria, we consider that the cell with the grouping criteria coming first in the model should be displayed below.\n * This can occur when some rows don't have all the fields. In which case we want the rows with the missing field to be displayed above.\n * TODO: Make this index comparator depth invariant, the logic should not be inverted when sorting in the \"desc\" direction (but the current return format of `sortComparator` does not support this behavior).\n */\nconst groupingFieldIndexComparator = (v1, v2, cellParams1, cellParams2) => {\n  var _groupingField, _groupingField2;\n  const model = gridRowGroupingSanitizedModelSelector(cellParams1.api.state, cellParams1.api.instanceId);\n  const groupingField1 = (_groupingField = cellParams1.rowNode.groupingField) != null ? _groupingField : null;\n  const groupingField2 = (_groupingField2 = cellParams2.rowNode.groupingField) != null ? _groupingField2 : null;\n  if (groupingField1 === groupingField2) {\n    return 0;\n  }\n  if (groupingField1 == null) {\n    return -1;\n  }\n  if (groupingField2 == null) {\n    return 1;\n  }\n  if (model.indexOf(groupingField1) < model.indexOf(groupingField2)) {\n    return -1;\n  }\n  return 1;\n};\nconst getLeafProperties = leafColDef => {\n  var _leafColDef$headerNam;\n  return {\n    headerName: (_leafColDef$headerNam = leafColDef.headerName) != null ? _leafColDef$headerNam : leafColDef.field,\n    sortable: leafColDef.sortable,\n    filterable: leafColDef.filterable,\n    valueOptions: isSingleSelectColDef(leafColDef) ? leafColDef.valueOptions : undefined,\n    filterOperators: leafColDef.filterOperators,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the leaves\n      if (cellParams1.rowNode.type === 'leaf' && cellParams2.rowNode.type === 'leaf') {\n        return leafColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    }\n  };\n};\nconst getGroupingCriteriaProperties = (groupedByColDef, applyHeaderName) => {\n  const properties = {\n    sortable: groupedByColDef.sortable,\n    filterable: groupedByColDef.filterable,\n    valueOptions: isSingleSelectColDef(groupedByColDef) ? groupedByColDef.valueOptions : undefined,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the groups of the current grouping criteria\n      if (cellParams1.rowNode.type === 'group' && cellParams1.rowNode.groupingField === groupedByColDef.field && cellParams2.rowNode.type === 'group' && cellParams2.rowNode.groupingField === groupedByColDef.field) {\n        return groupedByColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    },\n    filterOperators: groupedByColDef.filterOperators\n  };\n  if (applyHeaderName) {\n    var _groupedByColDef$head;\n    properties.headerName = (_groupedByColDef$head = groupedByColDef.headerName) != null ? _groupedByColDef$head : groupedByColDef.field;\n  }\n  return properties;\n};\n/**\n * Creates the `GridColDef` for a grouping column that only takes care of a single grouping criteria\n */\nexport const createGroupingColDefForOneGroupingCriteria = ({\n  columnsLookup,\n  groupedByColDef,\n  groupingCriteria,\n  colDefOverride\n}) => {\n  var _groupedByColDef$widt, _leafColDef$width;\n  const _ref = colDefOverride != null ? colDefOverride : {},\n    {\n      leafField,\n      mainGroupingCriteria,\n      hideDescendantCount\n    } = _ref,\n    colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const leafColDef = leafField ? columnsLookup[leafField] : null;\n\n  // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n  const commonProperties = {\n    width: Math.max(((_groupedByColDef$widt = groupedByColDef.width) != null ? _groupedByColDef$widt : GRID_STRING_COL_DEF.width) + 40, (_leafColDef$width = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width : 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      }\n\n      // Render leaves\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n        return '';\n      }\n\n      // Render current grouping criteria groups\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n          hideDescendantCount: hideDescendantCount\n        }));\n      }\n      return '';\n    },\n    valueGetter: params => {\n      if (!params.rowNode || params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n        return undefined;\n      }\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return params.rowNode.groupingKey;\n      }\n      return undefined;\n    }\n  };\n\n  // If we have a `mainGroupingCriteria` defined and matching the `groupingCriteria`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedByColDef`.\n  // It can be useful to define a `leafField` for leaves rendering but still use the grouping criteria for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedColDef`.\n  let sourceProperties;\n  if (mainGroupingCriteria && mainGroupingCriteria === groupingCriteria) {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  }\n\n  // The properties that can't be overridden with `colDefOverride`\n  const forcedProperties = _extends({\n    field: getRowGroupingFieldFromGroupingCriteria(groupingCriteria)\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\n/**\n * Creates the `GridColDef` for a grouping column that takes care of all the grouping criteria\n */\nexport const createGroupingColDefForAllGroupingCriteria = ({\n  apiRef,\n  columnsLookup,\n  rowGroupingModel,\n  colDefOverride\n}) => {\n  var _leafColDef$width2;\n  const _ref2 = colDefOverride != null ? colDefOverride : {},\n    {\n      leafField,\n      mainGroupingCriteria,\n      hideDescendantCount\n    } = _ref2,\n    colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n  const leafColDef = leafField ? columnsLookup[leafField] : null;\n\n  // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n  const commonProperties = {\n    headerName: apiRef.current.getLocaleText('groupingColumnHeaderName'),\n    width: Math.max(...rowGroupingModel.map(field => {\n      var _columnsLookup$field$;\n      return ((_columnsLookup$field$ = columnsLookup[field].width) != null ? _columnsLookup$field$ : GRID_STRING_COL_DEF.width) + 40;\n    }), (_leafColDef$width2 = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width2 : 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      }\n\n      // Render the leaves\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n        return '';\n      }\n\n      // Render the groups\n      return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n        hideDescendantCount: hideDescendantCount\n      }));\n    },\n    valueGetter: params => {\n      if (!params.rowNode || params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n        return undefined;\n      }\n      return params.rowNode.groupingKey;\n    }\n  };\n\n  // If we have a `mainGroupingCriteria` defined and matching one of the `orderedGroupedByFields`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `columnsLookup[mainGroupingCriteria]`.\n  // It can be useful to use another grouping criteria than the top level one for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of the top level grouping criteria based on the properties of `columnsLookup[orderedGroupedByFields[0]]`.\n  let sourceProperties;\n  if (mainGroupingCriteria && rowGroupingModel.includes(mainGroupingCriteria)) {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[mainGroupingCriteria], true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[rowGroupingModel[0]], rowGroupingModel.length === 1);\n  }\n\n  // The properties that can't be overridden with `colDefOverride`\n  const forcedProperties = _extends({\n    field: GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}