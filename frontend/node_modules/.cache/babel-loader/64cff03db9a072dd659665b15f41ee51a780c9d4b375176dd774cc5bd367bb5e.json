{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GridLogicOperator } from '../../../models';\nimport { GLOBAL_API_REF, isInternalFilter } from '../../../colDef/utils';\nimport { getDefaultGridFilterModel } from './gridFilterState';\nimport { buildWarning } from '../../../utils/warning';\nimport { gridColumnFieldsSelector, gridColumnLookupSelector, gridVisibleColumnFieldsSelector } from '../columns';\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operator.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\nexport const cleanFilterItem = (item, apiRef) => {\n  const cleanItem = _extends({}, item);\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n  if (cleanItem.operator == null) {\n    // Selects a default operator\n    // We don't use `apiRef.current.getColumn` because it is not ready during state initialization\n    const column = gridColumnLookupSelector(apiRef)[cleanItem.field];\n    cleanItem.operator = column && column.filterOperators[0].value;\n  }\n  return cleanItem;\n};\nconst filterModelDisableMultiColumnsFilteringWarning = buildWarning(['MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\nconst filterModelMissingItemIdWarning = buildWarning('MUI: The `id` field is required on `filterModel.items` when you use multiple filters.', 'error');\nconst filterModelMissingItemOperatorWarning = buildWarning('MUI: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.', 'error');\nexport const sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef) => {\n  const hasSeveralItems = model.items.length > 1;\n  let items;\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    filterModelDisableMultiColumnsFilteringWarning();\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n  const hasItemsWithoutIds = hasSeveralItems && items.some(item => item.id == null);\n  const hasItemWithoutOperator = items.some(item => item.operator == null);\n  if (hasItemsWithoutIds) {\n    filterModelMissingItemIdWarning();\n  }\n  if (hasItemWithoutOperator) {\n    filterModelMissingItemOperatorWarning();\n  }\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return _extends({}, model, {\n      items: items.map(item => cleanFilterItem(item, apiRef))\n    });\n  }\n  if (model.items !== items) {\n    return _extends({}, model, {\n      items\n    });\n  }\n  return model;\n};\nexport const mergeStateWithFilterModel = (filterModel, disableMultipleColumnsFiltering, apiRef) => filteringState => _extends({}, filteringState, {\n  filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n});\nconst getFilterCallbackFromItem = (filterItem, apiRef) => {\n  if (!filterItem.field || !filterItem.operator) {\n    return null;\n  }\n  const column = apiRef.current.getColumn(filterItem.field);\n  if (!column) {\n    return null;\n  }\n  let parsedValue;\n  if (column.valueParser) {\n    var _filterItem$value;\n    const parser = column.valueParser;\n    parsedValue = Array.isArray(filterItem.value) ? (_filterItem$value = filterItem.value) == null ? void 0 : _filterItem$value.map(x => parser(x)) : parser(filterItem.value);\n  } else {\n    parsedValue = filterItem.value;\n  }\n  const newFilterItem = _extends({}, filterItem, {\n    value: parsedValue\n  });\n  const filterOperators = column.filterOperators;\n  if (!(filterOperators != null && filterOperators.length)) {\n    throw new Error(`MUI: No filter operators found for column '${column.field}'.`);\n  }\n  const filterOperator = filterOperators.find(operator => operator.value === newFilterItem.operator);\n  if (!filterOperator) {\n    throw new Error(`MUI: No filter operator found for column '${column.field}' and operator value '${newFilterItem.operator}'.`);\n  }\n  const hasUserFunctionLegacy = !isInternalFilter(filterOperator.getApplyFilterFn);\n  const hasUserFunctionV7 = !isInternalFilter(filterOperator.getApplyFilterFnV7);\n  if (filterOperator.getApplyFilterFnV7 && !(hasUserFunctionLegacy && !hasUserFunctionV7)) {\n    const applyFilterOnRow = filterOperator.getApplyFilterFnV7(newFilterItem, column);\n    if (typeof applyFilterOnRow !== 'function') {\n      return null;\n    }\n    return {\n      v7: true,\n      item: newFilterItem,\n      fn: row => {\n        const value = apiRef.current.getRowValue(row, column);\n        return applyFilterOnRow(value, row, column, apiRef);\n      }\n    };\n  }\n  const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n  if (typeof applyFilterOnRow !== 'function') {\n    return null;\n  }\n  return {\n    v7: false,\n    item: newFilterItem,\n    fn: rowId => {\n      const params = apiRef.current.getCellParams(rowId, newFilterItem.field);\n      GLOBAL_API_REF.current = apiRef;\n      const result = applyFilterOnRow(params);\n      GLOBAL_API_REF.current = null;\n      return result;\n    }\n  };\n};\nlet filterItemsApplierId = 1;\n\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridRowIdGetter | undefined} getRowId The getter for row's id.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nexport const buildAggregatedFilterItemsApplier = (getRowId, filterModel, apiRef) => {\n  const {\n    items\n  } = filterModel;\n  const appliers = items.map(item => getFilterCallbackFromItem(item, apiRef)).filter(callback => !!callback);\n  if (appliers.length === 0) {\n    return null;\n  }\n\n  // Original logic:\n  // return (row, shouldApplyFilter) => {\n  //   const resultPerItemId: GridFilterItemResult = {};\n  //\n  //   for (let i = 0; i < appliers.length; i += 1) {\n  //     const applier = appliers[i];\n  //     if (!shouldApplyFilter || shouldApplyFilter(applier.item.field)) {\n  //       resultPerItemId[applier.item.id!] = applier.v7\n  //         ? applier.fn(row)\n  //         : applier.fn(getRowId ? getRowId(row) : row.id);\n  //     }\n  //   }\n  //\n  //   return resultPerItemId;\n  // };\n\n  // We generate a new function with `eval()` to avoid expensive patterns for JS engines\n  // such as a dynamic object assignment, e.g. `{ [dynamicKey]: value }`.\n  const filterItemTemplate = `(function filterItem$$(row, shouldApplyFilter) {\n      ${appliers.map((applier, i) => `const shouldApply${i} = !shouldApplyFilter || shouldApplyFilter(${JSON.stringify(applier.item.field)});`).join('\\n')}\n\n      const result$$ = {\n      ${appliers.map((applier, i) => `${JSON.stringify(String(applier.item.id))}:\n          !shouldApply${i} ?\n            false :\n            ${applier.v7 ? `appliers[${i}].fn(row)` : `appliers[${i}].fn(${getRowId ? 'getRowId(row)' : 'row.id'})`},\n      `).join('\\n')}};\n\n      return result$$;\n    })`;\n\n  // eslint-disable-next-line no-eval\n  const filterItem = eval(filterItemTemplate.replaceAll('$$', String(filterItemsApplierId)));\n  filterItemsApplierId += 1;\n  return filterItem;\n};\n\n/**\n * Generates a method to easily check if a row is matching the current quick filter.\n * @param {GridRowIdGetter | undefined} getRowId The getter for row's id.\n * @param {any[]} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nexport const buildAggregatedQuickFilterApplier = (getRowId, filterModel, apiRef) => {\n  var _filterModel$quickFil, _filterModel$quickFil2, _filterModel$quickFil3;\n  const quickFilterValues = (_filterModel$quickFil = (_filterModel$quickFil2 = filterModel.quickFilterValues) == null ? void 0 : _filterModel$quickFil2.filter(Boolean)) != null ? _filterModel$quickFil : [];\n  if (quickFilterValues.length === 0) {\n    return null;\n  }\n  const quickFilterExcludeHiddenColumns = (_filterModel$quickFil3 = filterModel.quickFilterExcludeHiddenColumns) != null ? _filterModel$quickFil3 : false;\n  const columnFields = quickFilterExcludeHiddenColumns ? gridVisibleColumnFieldsSelector(apiRef) : gridColumnFieldsSelector(apiRef);\n  const appliersPerField = [];\n  columnFields.forEach(field => {\n    const column = apiRef.current.getColumn(field);\n    const getApplyQuickFilterFn = column == null ? void 0 : column.getApplyQuickFilterFn;\n    const getApplyQuickFilterFnV7 = column == null ? void 0 : column.getApplyQuickFilterFnV7;\n    const hasUserFunctionLegacy = !isInternalFilter(getApplyQuickFilterFn);\n    const hasUserFunctionV7 = !isInternalFilter(getApplyQuickFilterFnV7);\n    if (getApplyQuickFilterFnV7 && !(hasUserFunctionLegacy && !hasUserFunctionV7)) {\n      appliersPerField.push({\n        column,\n        appliers: quickFilterValues.map(value => ({\n          v7: true,\n          fn: getApplyQuickFilterFnV7(value, column, apiRef)\n        }))\n      });\n    } else if (getApplyQuickFilterFn) {\n      appliersPerField.push({\n        column,\n        appliers: quickFilterValues.map(value => ({\n          v7: false,\n          fn: getApplyQuickFilterFn(value, column, apiRef)\n        }))\n      });\n    }\n  });\n  return function isRowMatchingQuickFilter(row, shouldApplyFilter) {\n    const result = {};\n    const usedCellParams = {};\n\n    /* eslint-disable no-restricted-syntax, no-labels, no-continue */\n    outer: for (let v = 0; v < quickFilterValues.length; v += 1) {\n      const filterValue = quickFilterValues[v];\n      for (let i = 0; i < appliersPerField.length; i += 1) {\n        const {\n          column,\n          appliers\n        } = appliersPerField[i];\n        const {\n          field\n        } = column;\n        if (shouldApplyFilter && !shouldApplyFilter(field)) {\n          continue;\n        }\n        const applier = appliers[v];\n        const value = apiRef.current.getRowValue(row, column);\n        if (applier.fn === null) {\n          continue;\n        }\n        if (applier.v7) {\n          const isMatching = applier.fn(value, row, column, apiRef);\n          if (isMatching) {\n            result[filterValue] = true;\n            continue outer;\n          }\n        } else {\n          var _usedCellParams$field;\n          const cellParams = (_usedCellParams$field = usedCellParams[field]) != null ? _usedCellParams$field : apiRef.current.getCellParams(getRowId ? getRowId(row) : row.id, field);\n          usedCellParams[field] = cellParams;\n          const isMatching = applier.fn(cellParams);\n          if (isMatching) {\n            result[filterValue] = true;\n            continue outer;\n          }\n        }\n      }\n      result[filterValue] = false;\n    }\n    /* eslint-enable no-restricted-syntax, no-labels, no-continue */\n\n    return result;\n  };\n};\nexport const buildAggregatedFilterApplier = (getRowId, filterModel, apiRef) => {\n  const isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(getRowId, filterModel, apiRef);\n  const isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(getRowId, filterModel, apiRef);\n  return function isRowMatchingFilters(row, shouldApplyFilter, result) {\n    var _isRowMatchingFilterI, _isRowMatchingQuickFi;\n    result.passingFilterItems = (_isRowMatchingFilterI = isRowMatchingFilterItems == null ? void 0 : isRowMatchingFilterItems(row, shouldApplyFilter)) != null ? _isRowMatchingFilterI : null;\n    result.passingQuickFilterValues = (_isRowMatchingQuickFi = isRowMatchingQuickFilter == null ? void 0 : isRowMatchingQuickFilter(row, shouldApplyFilter)) != null ? _isRowMatchingQuickFi : null;\n  };\n};\nconst isNotNull = result => result != null;\nconst filterModelItems = (cache, apiRef, items) => {\n  if (!cache.cleanedFilterItems) {\n    cache.cleanedFilterItems = items.filter(item => getFilterCallbackFromItem(item, apiRef) !== null);\n  }\n  return cache.cleanedFilterItems;\n};\nexport const passFilterLogic = (allFilterItemResults, allQuickFilterResults, filterModel, apiRef, cache) => {\n  const cleanedFilterItems = filterModelItems(cache, apiRef, filterModel.items);\n  const cleanedFilterItemResults = allFilterItemResults.filter(isNotNull);\n  const cleanedQuickFilterResults = allQuickFilterResults.filter(isNotNull);\n\n  // get result for filter items model\n  if (cleanedFilterItemResults.length > 0) {\n    var _filterModel$logicOpe;\n    // Return true if the item pass with one of the rows\n    const filterItemPredicate = item => {\n      return cleanedFilterItemResults.some(filterItemResult => filterItemResult[item.id]);\n    };\n    const logicOperator = (_filterModel$logicOpe = filterModel.logicOperator) != null ? _filterModel$logicOpe : getDefaultGridFilterModel().logicOperator;\n    if (logicOperator === GridLogicOperator.And) {\n      const passesAllFilters = cleanedFilterItems.every(filterItemPredicate);\n      if (!passesAllFilters) {\n        return false;\n      }\n    } else {\n      const passesSomeFilters = cleanedFilterItems.some(filterItemPredicate);\n      if (!passesSomeFilters) {\n        return false;\n      }\n    }\n  }\n\n  // get result for quick filter model\n  if (cleanedQuickFilterResults.length > 0 && filterModel.quickFilterValues != null) {\n    var _filterModel$quickFil4;\n    // Return true if the item pass with one of the rows\n    const quickFilterValuePredicate = value => {\n      return cleanedQuickFilterResults.some(quickFilterValueResult => quickFilterValueResult[value]);\n    };\n    const quickFilterLogicOperator = (_filterModel$quickFil4 = filterModel.quickFilterLogicOperator) != null ? _filterModel$quickFil4 : getDefaultGridFilterModel().quickFilterLogicOperator;\n    if (quickFilterLogicOperator === GridLogicOperator.And) {\n      const passesAllQuickFilterValues = filterModel.quickFilterValues.every(quickFilterValuePredicate);\n      if (!passesAllQuickFilterValues) {\n        return false;\n      }\n    } else {\n      const passesSomeQuickFilterValues = filterModel.quickFilterValues.some(quickFilterValuePredicate);\n      if (!passesSomeQuickFilterValues) {\n        return false;\n      }\n    }\n  }\n  return true;\n};","map":{"version":3,"names":["_extends","GridLogicOperator","GLOBAL_API_REF","isInternalFilter","getDefaultGridFilterModel","buildWarning","gridColumnFieldsSelector","gridColumnLookupSelector","gridVisibleColumnFieldsSelector","cleanFilterItem","item","apiRef","cleanItem","id","Math","round","random","operator","column","field","filterOperators","value","filterModelDisableMultiColumnsFilteringWarning","filterModelMissingItemIdWarning","filterModelMissingItemOperatorWarning","sanitizeFilterModel","model","disableMultipleColumnsFiltering","hasSeveralItems","items","length","hasItemsWithoutIds","some","hasItemWithoutOperator","map","mergeStateWithFilterModel","filterModel","filteringState","getFilterCallbackFromItem","filterItem","current","getColumn","parsedValue","valueParser","_filterItem$value","parser","Array","isArray","x","newFilterItem","Error","filterOperator","find","hasUserFunctionLegacy","getApplyFilterFn","hasUserFunctionV7","getApplyFilterFnV7","applyFilterOnRow","v7","fn","row","getRowValue","rowId","params","getCellParams","result","filterItemsApplierId","buildAggregatedFilterItemsApplier","getRowId","appliers","filter","callback","filterItemTemplate","applier","i","JSON","stringify","join","String","eval","replaceAll","buildAggregatedQuickFilterApplier","_filterModel$quickFil","_filterModel$quickFil2","_filterModel$quickFil3","quickFilterValues","Boolean","quickFilterExcludeHiddenColumns","columnFields","appliersPerField","forEach","getApplyQuickFilterFn","getApplyQuickFilterFnV7","push","isRowMatchingQuickFilter","shouldApplyFilter","usedCellParams","outer","v","filterValue","isMatching","_usedCellParams$field","cellParams","buildAggregatedFilterApplier","isRowMatchingFilterItems","isRowMatchingFilters","_isRowMatchingFilterI","_isRowMatchingQuickFi","passingFilterItems","passingQuickFilterValues","isNotNull","filterModelItems","cache","cleanedFilterItems","passFilterLogic","allFilterItemResults","allQuickFilterResults","cleanedFilterItemResults","cleanedQuickFilterResults","_filterModel$logicOpe","filterItemPredicate","filterItemResult","logicOperator","And","passesAllFilters","every","passesSomeFilters","_filterModel$quickFil4","quickFilterValuePredicate","quickFilterValueResult","quickFilterLogicOperator","passesAllQuickFilterValues","passesSomeQuickFilterValues"],"sources":["/Users/shyamkansagra/Documents/Code/general/pocket-wallet/node_modules/@mui/x-data-grid/hooks/features/filter/gridFilterUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GridLogicOperator } from '../../../models';\nimport { GLOBAL_API_REF, isInternalFilter } from '../../../colDef/utils';\nimport { getDefaultGridFilterModel } from './gridFilterState';\nimport { buildWarning } from '../../../utils/warning';\nimport { gridColumnFieldsSelector, gridColumnLookupSelector, gridVisibleColumnFieldsSelector } from '../columns';\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operator.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\nexport const cleanFilterItem = (item, apiRef) => {\n  const cleanItem = _extends({}, item);\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n  if (cleanItem.operator == null) {\n    // Selects a default operator\n    // We don't use `apiRef.current.getColumn` because it is not ready during state initialization\n    const column = gridColumnLookupSelector(apiRef)[cleanItem.field];\n    cleanItem.operator = column && column.filterOperators[0].value;\n  }\n  return cleanItem;\n};\nconst filterModelDisableMultiColumnsFilteringWarning = buildWarning(['MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\nconst filterModelMissingItemIdWarning = buildWarning('MUI: The `id` field is required on `filterModel.items` when you use multiple filters.', 'error');\nconst filterModelMissingItemOperatorWarning = buildWarning('MUI: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.', 'error');\nexport const sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef) => {\n  const hasSeveralItems = model.items.length > 1;\n  let items;\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    filterModelDisableMultiColumnsFilteringWarning();\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n  const hasItemsWithoutIds = hasSeveralItems && items.some(item => item.id == null);\n  const hasItemWithoutOperator = items.some(item => item.operator == null);\n  if (hasItemsWithoutIds) {\n    filterModelMissingItemIdWarning();\n  }\n  if (hasItemWithoutOperator) {\n    filterModelMissingItemOperatorWarning();\n  }\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return _extends({}, model, {\n      items: items.map(item => cleanFilterItem(item, apiRef))\n    });\n  }\n  if (model.items !== items) {\n    return _extends({}, model, {\n      items\n    });\n  }\n  return model;\n};\nexport const mergeStateWithFilterModel = (filterModel, disableMultipleColumnsFiltering, apiRef) => filteringState => _extends({}, filteringState, {\n  filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n});\nconst getFilterCallbackFromItem = (filterItem, apiRef) => {\n  if (!filterItem.field || !filterItem.operator) {\n    return null;\n  }\n  const column = apiRef.current.getColumn(filterItem.field);\n  if (!column) {\n    return null;\n  }\n  let parsedValue;\n  if (column.valueParser) {\n    var _filterItem$value;\n    const parser = column.valueParser;\n    parsedValue = Array.isArray(filterItem.value) ? (_filterItem$value = filterItem.value) == null ? void 0 : _filterItem$value.map(x => parser(x)) : parser(filterItem.value);\n  } else {\n    parsedValue = filterItem.value;\n  }\n  const newFilterItem = _extends({}, filterItem, {\n    value: parsedValue\n  });\n  const filterOperators = column.filterOperators;\n  if (!(filterOperators != null && filterOperators.length)) {\n    throw new Error(`MUI: No filter operators found for column '${column.field}'.`);\n  }\n  const filterOperator = filterOperators.find(operator => operator.value === newFilterItem.operator);\n  if (!filterOperator) {\n    throw new Error(`MUI: No filter operator found for column '${column.field}' and operator value '${newFilterItem.operator}'.`);\n  }\n  const hasUserFunctionLegacy = !isInternalFilter(filterOperator.getApplyFilterFn);\n  const hasUserFunctionV7 = !isInternalFilter(filterOperator.getApplyFilterFnV7);\n  if (filterOperator.getApplyFilterFnV7 && !(hasUserFunctionLegacy && !hasUserFunctionV7)) {\n    const applyFilterOnRow = filterOperator.getApplyFilterFnV7(newFilterItem, column);\n    if (typeof applyFilterOnRow !== 'function') {\n      return null;\n    }\n    return {\n      v7: true,\n      item: newFilterItem,\n      fn: row => {\n        const value = apiRef.current.getRowValue(row, column);\n        return applyFilterOnRow(value, row, column, apiRef);\n      }\n    };\n  }\n  const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n  if (typeof applyFilterOnRow !== 'function') {\n    return null;\n  }\n  return {\n    v7: false,\n    item: newFilterItem,\n    fn: rowId => {\n      const params = apiRef.current.getCellParams(rowId, newFilterItem.field);\n      GLOBAL_API_REF.current = apiRef;\n      const result = applyFilterOnRow(params);\n      GLOBAL_API_REF.current = null;\n      return result;\n    }\n  };\n};\nlet filterItemsApplierId = 1;\n\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridRowIdGetter | undefined} getRowId The getter for row's id.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nexport const buildAggregatedFilterItemsApplier = (getRowId, filterModel, apiRef) => {\n  const {\n    items\n  } = filterModel;\n  const appliers = items.map(item => getFilterCallbackFromItem(item, apiRef)).filter(callback => !!callback);\n  if (appliers.length === 0) {\n    return null;\n  }\n\n  // Original logic:\n  // return (row, shouldApplyFilter) => {\n  //   const resultPerItemId: GridFilterItemResult = {};\n  //\n  //   for (let i = 0; i < appliers.length; i += 1) {\n  //     const applier = appliers[i];\n  //     if (!shouldApplyFilter || shouldApplyFilter(applier.item.field)) {\n  //       resultPerItemId[applier.item.id!] = applier.v7\n  //         ? applier.fn(row)\n  //         : applier.fn(getRowId ? getRowId(row) : row.id);\n  //     }\n  //   }\n  //\n  //   return resultPerItemId;\n  // };\n\n  // We generate a new function with `eval()` to avoid expensive patterns for JS engines\n  // such as a dynamic object assignment, e.g. `{ [dynamicKey]: value }`.\n  const filterItemTemplate = `(function filterItem$$(row, shouldApplyFilter) {\n      ${appliers.map((applier, i) => `const shouldApply${i} = !shouldApplyFilter || shouldApplyFilter(${JSON.stringify(applier.item.field)});`).join('\\n')}\n\n      const result$$ = {\n      ${appliers.map((applier, i) => `${JSON.stringify(String(applier.item.id))}:\n          !shouldApply${i} ?\n            false :\n            ${applier.v7 ? `appliers[${i}].fn(row)` : `appliers[${i}].fn(${getRowId ? 'getRowId(row)' : 'row.id'})`},\n      `).join('\\n')}};\n\n      return result$$;\n    })`;\n\n  // eslint-disable-next-line no-eval\n  const filterItem = eval(filterItemTemplate.replaceAll('$$', String(filterItemsApplierId)));\n  filterItemsApplierId += 1;\n  return filterItem;\n};\n\n/**\n * Generates a method to easily check if a row is matching the current quick filter.\n * @param {GridRowIdGetter | undefined} getRowId The getter for row's id.\n * @param {any[]} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nexport const buildAggregatedQuickFilterApplier = (getRowId, filterModel, apiRef) => {\n  var _filterModel$quickFil, _filterModel$quickFil2, _filterModel$quickFil3;\n  const quickFilterValues = (_filterModel$quickFil = (_filterModel$quickFil2 = filterModel.quickFilterValues) == null ? void 0 : _filterModel$quickFil2.filter(Boolean)) != null ? _filterModel$quickFil : [];\n  if (quickFilterValues.length === 0) {\n    return null;\n  }\n  const quickFilterExcludeHiddenColumns = (_filterModel$quickFil3 = filterModel.quickFilterExcludeHiddenColumns) != null ? _filterModel$quickFil3 : false;\n  const columnFields = quickFilterExcludeHiddenColumns ? gridVisibleColumnFieldsSelector(apiRef) : gridColumnFieldsSelector(apiRef);\n  const appliersPerField = [];\n  columnFields.forEach(field => {\n    const column = apiRef.current.getColumn(field);\n    const getApplyQuickFilterFn = column == null ? void 0 : column.getApplyQuickFilterFn;\n    const getApplyQuickFilterFnV7 = column == null ? void 0 : column.getApplyQuickFilterFnV7;\n    const hasUserFunctionLegacy = !isInternalFilter(getApplyQuickFilterFn);\n    const hasUserFunctionV7 = !isInternalFilter(getApplyQuickFilterFnV7);\n    if (getApplyQuickFilterFnV7 && !(hasUserFunctionLegacy && !hasUserFunctionV7)) {\n      appliersPerField.push({\n        column,\n        appliers: quickFilterValues.map(value => ({\n          v7: true,\n          fn: getApplyQuickFilterFnV7(value, column, apiRef)\n        }))\n      });\n    } else if (getApplyQuickFilterFn) {\n      appliersPerField.push({\n        column,\n        appliers: quickFilterValues.map(value => ({\n          v7: false,\n          fn: getApplyQuickFilterFn(value, column, apiRef)\n        }))\n      });\n    }\n  });\n  return function isRowMatchingQuickFilter(row, shouldApplyFilter) {\n    const result = {};\n    const usedCellParams = {};\n\n    /* eslint-disable no-restricted-syntax, no-labels, no-continue */\n    outer: for (let v = 0; v < quickFilterValues.length; v += 1) {\n      const filterValue = quickFilterValues[v];\n      for (let i = 0; i < appliersPerField.length; i += 1) {\n        const {\n          column,\n          appliers\n        } = appliersPerField[i];\n        const {\n          field\n        } = column;\n        if (shouldApplyFilter && !shouldApplyFilter(field)) {\n          continue;\n        }\n        const applier = appliers[v];\n        const value = apiRef.current.getRowValue(row, column);\n        if (applier.fn === null) {\n          continue;\n        }\n        if (applier.v7) {\n          const isMatching = applier.fn(value, row, column, apiRef);\n          if (isMatching) {\n            result[filterValue] = true;\n            continue outer;\n          }\n        } else {\n          var _usedCellParams$field;\n          const cellParams = (_usedCellParams$field = usedCellParams[field]) != null ? _usedCellParams$field : apiRef.current.getCellParams(getRowId ? getRowId(row) : row.id, field);\n          usedCellParams[field] = cellParams;\n          const isMatching = applier.fn(cellParams);\n          if (isMatching) {\n            result[filterValue] = true;\n            continue outer;\n          }\n        }\n      }\n      result[filterValue] = false;\n    }\n    /* eslint-enable no-restricted-syntax, no-labels, no-continue */\n\n    return result;\n  };\n};\nexport const buildAggregatedFilterApplier = (getRowId, filterModel, apiRef) => {\n  const isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(getRowId, filterModel, apiRef);\n  const isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(getRowId, filterModel, apiRef);\n  return function isRowMatchingFilters(row, shouldApplyFilter, result) {\n    var _isRowMatchingFilterI, _isRowMatchingQuickFi;\n    result.passingFilterItems = (_isRowMatchingFilterI = isRowMatchingFilterItems == null ? void 0 : isRowMatchingFilterItems(row, shouldApplyFilter)) != null ? _isRowMatchingFilterI : null;\n    result.passingQuickFilterValues = (_isRowMatchingQuickFi = isRowMatchingQuickFilter == null ? void 0 : isRowMatchingQuickFilter(row, shouldApplyFilter)) != null ? _isRowMatchingQuickFi : null;\n  };\n};\nconst isNotNull = result => result != null;\nconst filterModelItems = (cache, apiRef, items) => {\n  if (!cache.cleanedFilterItems) {\n    cache.cleanedFilterItems = items.filter(item => getFilterCallbackFromItem(item, apiRef) !== null);\n  }\n  return cache.cleanedFilterItems;\n};\nexport const passFilterLogic = (allFilterItemResults, allQuickFilterResults, filterModel, apiRef, cache) => {\n  const cleanedFilterItems = filterModelItems(cache, apiRef, filterModel.items);\n  const cleanedFilterItemResults = allFilterItemResults.filter(isNotNull);\n  const cleanedQuickFilterResults = allQuickFilterResults.filter(isNotNull);\n\n  // get result for filter items model\n  if (cleanedFilterItemResults.length > 0) {\n    var _filterModel$logicOpe;\n    // Return true if the item pass with one of the rows\n    const filterItemPredicate = item => {\n      return cleanedFilterItemResults.some(filterItemResult => filterItemResult[item.id]);\n    };\n    const logicOperator = (_filterModel$logicOpe = filterModel.logicOperator) != null ? _filterModel$logicOpe : getDefaultGridFilterModel().logicOperator;\n    if (logicOperator === GridLogicOperator.And) {\n      const passesAllFilters = cleanedFilterItems.every(filterItemPredicate);\n      if (!passesAllFilters) {\n        return false;\n      }\n    } else {\n      const passesSomeFilters = cleanedFilterItems.some(filterItemPredicate);\n      if (!passesSomeFilters) {\n        return false;\n      }\n    }\n  }\n\n  // get result for quick filter model\n  if (cleanedQuickFilterResults.length > 0 && filterModel.quickFilterValues != null) {\n    var _filterModel$quickFil4;\n    // Return true if the item pass with one of the rows\n    const quickFilterValuePredicate = value => {\n      return cleanedQuickFilterResults.some(quickFilterValueResult => quickFilterValueResult[value]);\n    };\n    const quickFilterLogicOperator = (_filterModel$quickFil4 = filterModel.quickFilterLogicOperator) != null ? _filterModel$quickFil4 : getDefaultGridFilterModel().quickFilterLogicOperator;\n    if (quickFilterLogicOperator === GridLogicOperator.And) {\n      const passesAllQuickFilterValues = filterModel.quickFilterValues.every(quickFilterValuePredicate);\n      if (!passesAllQuickFilterValues) {\n        return false;\n      }\n    } else {\n      const passesSomeQuickFilterValues = filterModel.quickFilterValues.some(quickFilterValuePredicate);\n      if (!passesSomeQuickFilterValues) {\n        return false;\n      }\n    }\n  }\n  return true;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}