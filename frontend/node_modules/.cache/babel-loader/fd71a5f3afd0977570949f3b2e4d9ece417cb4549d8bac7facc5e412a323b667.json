{"ast":null,"code":"import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { updateGroupDefaultExpansion, getGroupRowIdFromPath, insertNodeInTree, updateGroupNodeIdAndAutoGenerated } from './utils';\n/**\n * Inserts a data row in a tree.\n * For each steps of its path:\n * - if a node exists with the same partial path, it will register this node as the ancestor of the data row.\n * - if not, it will create an auto-generated node and register it as ancestor of the data row.\n */\nexport const insertDataRowInTree = ({\n  id,\n  path,\n  updatedGroupsManager,\n  previousTree,\n  tree,\n  treeDepths,\n  onDuplicatePath,\n  isGroupExpandedByDefault,\n  defaultGroupingExpansionDepth\n}) => {\n  let parentNodeId = GRID_ROOT_GROUP_ID;\n  for (let depth = 0; depth < path.length; depth += 1) {\n    var _childrenFromPath;\n    const {\n      key,\n      field\n    } = path[depth];\n    const fieldWithDefaultValue = field != null ? field : '__no_field__';\n    const keyWithDefaultValue = key != null ? key : '__no_key__';\n    const existingNodeIdWithPartialPath = (_childrenFromPath = tree[parentNodeId].childrenFromPath) == null || (_childrenFromPath = _childrenFromPath[fieldWithDefaultValue]) == null ? void 0 : _childrenFromPath[keyWithDefaultValue.toString()];\n\n    // When we reach the last step of the path,\n    // We need to create a node for the row passed to `insertNodeInTree`\n    if (depth === path.length - 1) {\n      // If no node matches the full path,\n      // We create a leaf node for the data row.\n      if (existingNodeIdWithPartialPath == null) {\n        const leafNode = {\n          type: 'leaf',\n          id,\n          depth,\n          parent: parentNodeId,\n          groupingKey: key\n        };\n        updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n        insertNodeInTree(leafNode, tree, treeDepths, previousTree);\n      } else {\n        const existingNodeWithPartialPath = tree[existingNodeIdWithPartialPath];\n\n        // If we already have an auto-generated group matching the partial path,\n        // We replace it with the node from of data row passed to `insertNodeInTree`\n        if (existingNodeWithPartialPath.type === 'group' && existingNodeWithPartialPath.isAutoGenerated) {\n          updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'removeChildren');\n          updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n          updateGroupNodeIdAndAutoGenerated({\n            tree,\n            previousTree,\n            treeDepths,\n            node: existingNodeWithPartialPath,\n            updatedNode: {\n              id,\n              isAutoGenerated: false\n            }\n          });\n        } else {\n          // If we have another row matching the partial path, then there is a duplicate in the dataset.\n          // We warn the user and skip the current row.\n          onDuplicatePath == null ? void 0 : onDuplicatePath(existingNodeIdWithPartialPath, id, path);\n        }\n      }\n    }\n    // For the intermediary steps of the path,\n    // We need to make sure that there is a node matching the partial path.\n    //\n    // If no node matches the partial path,\n    // We create an auto-generated group node.\n    else if (existingNodeIdWithPartialPath == null) {\n      const nodeId = getGroupRowIdFromPath(path.slice(0, depth + 1));\n      const autoGeneratedGroupNode = {\n        type: 'group',\n        id: nodeId,\n        parent: parentNodeId,\n        depth,\n        isAutoGenerated: true,\n        groupingKey: key,\n        groupingField: field,\n        children: [],\n        childrenFromPath: {},\n        childrenExpanded: false\n      };\n      updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n      insertNodeInTree(updateGroupDefaultExpansion(autoGeneratedGroupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault), tree, treeDepths, previousTree);\n      parentNodeId = nodeId;\n    }\n    // For the intermediary steps of the path\n    // If a node matches the partial path, we use it as parent for the next step\n    else {\n      const currentGroupNode = tree[existingNodeIdWithPartialPath];\n\n      // If the node matching the partial path is not a group, we turn it into a group\n      if (currentGroupNode.type !== 'group') {\n        const groupNode = {\n          type: 'group',\n          id: currentGroupNode.id,\n          parent: currentGroupNode.parent,\n          depth: currentGroupNode.depth,\n          isAutoGenerated: false,\n          groupingKey: key,\n          groupingField: field,\n          children: [],\n          childrenFromPath: {},\n          childrenExpanded: false\n        };\n        tree[existingNodeIdWithPartialPath] = updateGroupDefaultExpansion(groupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault);\n      }\n      parentNodeId = currentGroupNode.id;\n    }\n  }\n};","map":{"version":3,"names":["GRID_ROOT_GROUP_ID","updateGroupDefaultExpansion","getGroupRowIdFromPath","insertNodeInTree","updateGroupNodeIdAndAutoGenerated","insertDataRowInTree","id","path","updatedGroupsManager","previousTree","tree","treeDepths","onDuplicatePath","isGroupExpandedByDefault","defaultGroupingExpansionDepth","parentNodeId","depth","length","_childrenFromPath","key","field","fieldWithDefaultValue","keyWithDefaultValue","existingNodeIdWithPartialPath","childrenFromPath","toString","leafNode","type","parent","groupingKey","addAction","existingNodeWithPartialPath","isAutoGenerated","node","updatedNode","nodeId","slice","autoGeneratedGroupNode","groupingField","children","childrenExpanded","currentGroupNode","groupNode"],"sources":["/Users/shyamkansagra/Documents/Code/general/pocket-wallet/node_modules/@mui/x-data-grid-pro/utils/tree/insertDataRowInTree.js"],"sourcesContent":["import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { updateGroupDefaultExpansion, getGroupRowIdFromPath, insertNodeInTree, updateGroupNodeIdAndAutoGenerated } from './utils';\n/**\n * Inserts a data row in a tree.\n * For each steps of its path:\n * - if a node exists with the same partial path, it will register this node as the ancestor of the data row.\n * - if not, it will create an auto-generated node and register it as ancestor of the data row.\n */\nexport const insertDataRowInTree = ({\n  id,\n  path,\n  updatedGroupsManager,\n  previousTree,\n  tree,\n  treeDepths,\n  onDuplicatePath,\n  isGroupExpandedByDefault,\n  defaultGroupingExpansionDepth\n}) => {\n  let parentNodeId = GRID_ROOT_GROUP_ID;\n  for (let depth = 0; depth < path.length; depth += 1) {\n    var _childrenFromPath;\n    const {\n      key,\n      field\n    } = path[depth];\n    const fieldWithDefaultValue = field != null ? field : '__no_field__';\n    const keyWithDefaultValue = key != null ? key : '__no_key__';\n    const existingNodeIdWithPartialPath = (_childrenFromPath = tree[parentNodeId].childrenFromPath) == null || (_childrenFromPath = _childrenFromPath[fieldWithDefaultValue]) == null ? void 0 : _childrenFromPath[keyWithDefaultValue.toString()];\n\n    // When we reach the last step of the path,\n    // We need to create a node for the row passed to `insertNodeInTree`\n    if (depth === path.length - 1) {\n      // If no node matches the full path,\n      // We create a leaf node for the data row.\n      if (existingNodeIdWithPartialPath == null) {\n        const leafNode = {\n          type: 'leaf',\n          id,\n          depth,\n          parent: parentNodeId,\n          groupingKey: key\n        };\n        updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n        insertNodeInTree(leafNode, tree, treeDepths, previousTree);\n      } else {\n        const existingNodeWithPartialPath = tree[existingNodeIdWithPartialPath];\n\n        // If we already have an auto-generated group matching the partial path,\n        // We replace it with the node from of data row passed to `insertNodeInTree`\n        if (existingNodeWithPartialPath.type === 'group' && existingNodeWithPartialPath.isAutoGenerated) {\n          updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'removeChildren');\n          updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n          updateGroupNodeIdAndAutoGenerated({\n            tree,\n            previousTree,\n            treeDepths,\n            node: existingNodeWithPartialPath,\n            updatedNode: {\n              id,\n              isAutoGenerated: false\n            }\n          });\n        } else {\n          // If we have another row matching the partial path, then there is a duplicate in the dataset.\n          // We warn the user and skip the current row.\n          onDuplicatePath == null ? void 0 : onDuplicatePath(existingNodeIdWithPartialPath, id, path);\n        }\n      }\n    }\n    // For the intermediary steps of the path,\n    // We need to make sure that there is a node matching the partial path.\n    //\n    // If no node matches the partial path,\n    // We create an auto-generated group node.\n    else if (existingNodeIdWithPartialPath == null) {\n      const nodeId = getGroupRowIdFromPath(path.slice(0, depth + 1));\n      const autoGeneratedGroupNode = {\n        type: 'group',\n        id: nodeId,\n        parent: parentNodeId,\n        depth,\n        isAutoGenerated: true,\n        groupingKey: key,\n        groupingField: field,\n        children: [],\n        childrenFromPath: {},\n        childrenExpanded: false\n      };\n      updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n      insertNodeInTree(updateGroupDefaultExpansion(autoGeneratedGroupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault), tree, treeDepths, previousTree);\n      parentNodeId = nodeId;\n    }\n    // For the intermediary steps of the path\n    // If a node matches the partial path, we use it as parent for the next step\n    else {\n      const currentGroupNode = tree[existingNodeIdWithPartialPath];\n\n      // If the node matching the partial path is not a group, we turn it into a group\n      if (currentGroupNode.type !== 'group') {\n        const groupNode = {\n          type: 'group',\n          id: currentGroupNode.id,\n          parent: currentGroupNode.parent,\n          depth: currentGroupNode.depth,\n          isAutoGenerated: false,\n          groupingKey: key,\n          groupingField: field,\n          children: [],\n          childrenFromPath: {},\n          childrenExpanded: false\n        };\n        tree[existingNodeIdWithPartialPath] = updateGroupDefaultExpansion(groupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault);\n      }\n      parentNodeId = currentGroupNode.id;\n    }\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}