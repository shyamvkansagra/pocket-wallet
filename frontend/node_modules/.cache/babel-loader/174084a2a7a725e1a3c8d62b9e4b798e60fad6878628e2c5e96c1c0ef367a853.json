{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useTheme } from '@mui/material/styles';\nimport { useGridSelector, gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector, gridVisibleColumnFieldsSelector, gridClasses, useGridApiMethod, useGridApiEventHandler, gridColumnFieldsSelector } from '@mui/x-data-grid';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { GridPinnedPosition } from './gridColumnPinningInterface';\nimport { gridPinnedColumnsSelector } from './gridColumnPinningSelector';\nimport { filterColumns } from '../../../components/DataGridProVirtualScroller';\nexport const columnPinningStateInitializer = (state, props, apiRef) => {\n  var _props$initialState;\n  apiRef.current.caches.columnPinning = {\n    orderedFieldsBeforePinningColumns: null\n  };\n  let model;\n  if (props.disableColumnPinning) {\n    model = {};\n  } else if (props.pinnedColumns) {\n    model = props.pinnedColumns;\n  } else if ((_props$initialState = props.initialState) != null && _props$initialState.pinnedColumns) {\n    var _props$initialState2;\n    model = (_props$initialState2 = props.initialState) == null ? void 0 : _props$initialState2.pinnedColumns;\n  } else {\n    model = {};\n  }\n  return _extends({}, state, {\n    pinnedColumns: model\n  });\n};\nconst mergeStateWithPinnedColumns = pinnedColumns => state => _extends({}, state, {\n  pinnedColumns\n});\nexport const useGridColumnPinning = (apiRef, props) => {\n  var _props$initialState4;\n  const pinnedColumns = useGridSelector(apiRef, gridPinnedColumnsSelector);\n  const theme = useTheme();\n  // Each visible row (not to be confused with a filter result) is composed of a central .MuiDataGrid-row element\n  // and up to two additional .MuiDataGrid-row's, one for the columns pinned to the left and another\n  // for those on the right side. When hovering any of these elements, the :hover styles are applied only to\n  // the row element that was actually hovered, not its additional siblings. To make it look like a contiguous row,\n  // this method adds/removes the .Mui-hovered class to all of the row elements inside one visible row.\n  const updateHoveredClassOnSiblingRows = React.useCallback(event => {\n    var _pinnedColumns$left$l, _pinnedColumns$left, _pinnedColumns$right$, _pinnedColumns$right;\n    if (props.disableColumnPinning) {\n      return;\n    }\n    if (!Array.isArray(pinnedColumns.left) && !Array.isArray(pinnedColumns.right)) {\n      return;\n    }\n    const nbLeftPinnedColumns = (_pinnedColumns$left$l = (_pinnedColumns$left = pinnedColumns.left) == null ? void 0 : _pinnedColumns$left.length) != null ? _pinnedColumns$left$l : 0;\n    const nbRightPinnedColumns = (_pinnedColumns$right$ = (_pinnedColumns$right = pinnedColumns.right) == null ? void 0 : _pinnedColumns$right.length) != null ? _pinnedColumns$right$ : 0;\n    if (nbLeftPinnedColumns + nbRightPinnedColumns === 0) {\n      return;\n    }\n    const rowContainer = apiRef.current.virtualScrollerRef.current;\n    if (!rowContainer) {\n      return;\n    }\n    const index = event.currentTarget.dataset.rowindex;\n    const rowElements = rowContainer.querySelectorAll(`.${gridClasses.row}[data-rowindex=\"${index}\"]`);\n    rowElements.forEach(row => {\n      // Ignore rows from other grid inside the hovered row\n      if (row.closest(`.${gridClasses.virtualScroller}`) === apiRef.current.virtualScrollerRef.current) {\n        if (event.type === 'mouseenter') {\n          row.classList.add('Mui-hovered');\n        } else {\n          row.classList.remove('Mui-hovered');\n        }\n      }\n    });\n  }, [apiRef, pinnedColumns.left, pinnedColumns.right, props.disableColumnPinning]);\n  const handleMouseEnter = React.useCallback((params, event) => {\n    updateHoveredClassOnSiblingRows(event);\n  }, [updateHoveredClassOnSiblingRows]);\n  const handleMouseLeave = React.useCallback((params, event) => {\n    updateHoveredClassOnSiblingRows(event);\n  }, [updateHoveredClassOnSiblingRows]);\n  useGridApiEventHandler(apiRef, 'rowMouseEnter', handleMouseEnter);\n  useGridApiEventHandler(apiRef, 'rowMouseLeave', handleMouseLeave);\n\n  /**\n   * PRE-PROCESSING\n   */\n  const calculateScrollLeft = React.useCallback((initialValue, params) => {\n    if (props.disableColumnPinning) {\n      return initialValue;\n    }\n    const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef);\n    const [leftPinnedColumns, rightPinnedColumns] = filterColumns(pinnedColumns, visibleColumnFields, theme.direction === 'rtl');\n    if (!params.colIndex || leftPinnedColumns.length === 0 && rightPinnedColumns.length === 0) {\n      return initialValue;\n    }\n    const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);\n    const columnsTotalWidth = gridColumnsTotalWidthSelector(apiRef);\n    const columnPositions = gridColumnPositionsSelector(apiRef);\n    const clientWidth = apiRef.current.virtualScrollerRef.current.clientWidth;\n\n    // When using RTL, `scrollLeft` becomes negative, so we must ensure that we only compare values.\n    const scrollLeft = Math.abs(apiRef.current.virtualScrollerRef.current.scrollLeft);\n    const offsetWidth = visibleColumns[params.colIndex].computedWidth;\n    const offsetLeft = columnPositions[params.colIndex];\n    const leftPinnedColumnsWidth = columnPositions[leftPinnedColumns.length];\n    const rightPinnedColumnsWidth = columnsTotalWidth - columnPositions[columnPositions.length - rightPinnedColumns.length];\n    const elementBottom = offsetLeft + offsetWidth;\n    if (elementBottom - (clientWidth - rightPinnedColumnsWidth) > scrollLeft) {\n      const left = elementBottom - (clientWidth - rightPinnedColumnsWidth);\n      return _extends({}, initialValue, {\n        left\n      });\n    }\n    if (offsetLeft < scrollLeft + leftPinnedColumnsWidth) {\n      const left = offsetLeft - leftPinnedColumnsWidth;\n      return _extends({}, initialValue, {\n        left\n      });\n    }\n    return initialValue;\n  }, [apiRef, pinnedColumns, props.disableColumnPinning, theme.direction]);\n  const addColumnMenuItems = React.useCallback((columnMenuItems, colDef) => {\n    if (props.disableColumnPinning) {\n      return columnMenuItems;\n    }\n    if (colDef.pinnable === false) {\n      return columnMenuItems;\n    }\n    return [...columnMenuItems, 'columnMenuPinningItem'];\n  }, [props.disableColumnPinning]);\n  const checkIfCanBeReordered = React.useCallback((initialValue, {\n    targetIndex\n  }) => {\n    const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef);\n    const [leftPinnedColumns, rightPinnedColumns] = filterColumns(pinnedColumns, visibleColumnFields, theme.direction === 'rtl');\n    if (leftPinnedColumns.length === 0 && rightPinnedColumns.length === 0) {\n      return initialValue;\n    }\n    if (leftPinnedColumns.length > 0 && targetIndex < leftPinnedColumns.length) {\n      return false;\n    }\n    if (rightPinnedColumns.length > 0) {\n      const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);\n      const firstRightPinnedColumnIndex = visibleColumns.length - rightPinnedColumns.length;\n      return targetIndex >= firstRightPinnedColumnIndex ? false : initialValue;\n    }\n    return initialValue;\n  }, [apiRef, pinnedColumns, theme.direction]);\n  const stateExportPreProcessing = React.useCallback((prevState, context) => {\n    var _props$initialState3, _pinnedColumnsToExpor, _pinnedColumnsToExpor2;\n    const pinnedColumnsToExport = gridPinnedColumnsSelector(apiRef.current.state);\n    const shouldExportPinnedColumns =\n    // Always export if the `exportOnlyDirtyModels` property is not activated\n    !context.exportOnlyDirtyModels ||\n    // Always export if the model is controlled\n    props.pinnedColumns != null ||\n    // Always export if the model has been initialized\n    ((_props$initialState3 = props.initialState) == null ? void 0 : _props$initialState3.pinnedColumns) != null ||\n    // Export if the model is not empty\n    ((_pinnedColumnsToExpor = pinnedColumnsToExport.left) != null ? _pinnedColumnsToExpor : []).length > 0 || ((_pinnedColumnsToExpor2 = pinnedColumnsToExport.right) != null ? _pinnedColumnsToExpor2 : []).length > 0;\n    if (!shouldExportPinnedColumns) {\n      return prevState;\n    }\n    return _extends({}, prevState, {\n      pinnedColumns: pinnedColumnsToExport\n    });\n  }, [apiRef, props.pinnedColumns, (_props$initialState4 = props.initialState) == null ? void 0 : _props$initialState4.pinnedColumns]);\n  const stateRestorePreProcessing = React.useCallback((params, context) => {\n    const newPinnedColumns = context.stateToRestore.pinnedColumns;\n    if (newPinnedColumns != null) {\n      apiRef.current.setState(mergeStateWithPinnedColumns(newPinnedColumns));\n    }\n    return params;\n  }, [apiRef]);\n  useGridRegisterPipeProcessor(apiRef, 'scrollToIndexes', calculateScrollLeft);\n  useGridRegisterPipeProcessor(apiRef, 'columnMenu', addColumnMenuItems);\n  useGridRegisterPipeProcessor(apiRef, 'canBeReordered', checkIfCanBeReordered);\n  useGridRegisterPipeProcessor(apiRef, 'exportState', stateExportPreProcessing);\n  useGridRegisterPipeProcessor(apiRef, 'restoreState', stateRestorePreProcessing);\n  apiRef.current.registerControlState({\n    stateId: 'pinnedColumns',\n    propModel: props.pinnedColumns,\n    propOnChange: props.onPinnedColumnsChange,\n    stateSelector: gridPinnedColumnsSelector,\n    changeEvent: 'pinnedColumnsChange'\n  });\n  const checkIfEnabled = React.useCallback(methodName => {\n    if (props.disableColumnPinning) {\n      throw new Error(`MUI: You cannot call \\`apiRef.current.${methodName}\\` when \\`disableColumnPinning\\` is true.`);\n    }\n  }, [props.disableColumnPinning]);\n  const pinColumn = React.useCallback((field, side) => {\n    checkIfEnabled('pinColumn');\n    if (apiRef.current.isColumnPinned(field) === side) {\n      return;\n    }\n    const otherSide = side === GridPinnedPosition.right ? GridPinnedPosition.left : GridPinnedPosition.right;\n    const newPinnedColumns = {\n      [side]: [...(pinnedColumns[side] || []), field],\n      [otherSide]: (pinnedColumns[otherSide] || []).filter(column => column !== field)\n    };\n    apiRef.current.setPinnedColumns(newPinnedColumns);\n  }, [apiRef, checkIfEnabled, pinnedColumns]);\n  const unpinColumn = React.useCallback(field => {\n    checkIfEnabled('unpinColumn');\n    apiRef.current.setPinnedColumns({\n      left: (pinnedColumns.left || []).filter(column => column !== field),\n      right: (pinnedColumns.right || []).filter(column => column !== field)\n    });\n  }, [apiRef, checkIfEnabled, pinnedColumns.left, pinnedColumns.right]);\n  const getPinnedColumns = React.useCallback(() => {\n    checkIfEnabled('getPinnedColumns');\n    return gridPinnedColumnsSelector(apiRef.current.state);\n  }, [apiRef, checkIfEnabled]);\n  const setPinnedColumns = React.useCallback(newPinnedColumns => {\n    checkIfEnabled('setPinnedColumns');\n    apiRef.current.setState(mergeStateWithPinnedColumns(newPinnedColumns));\n    apiRef.current.forceUpdate();\n  }, [apiRef, checkIfEnabled]);\n  const isColumnPinned = React.useCallback(field => {\n    checkIfEnabled('isColumnPinned');\n    const leftPinnedColumns = pinnedColumns.left || [];\n    if (leftPinnedColumns.includes(field)) {\n      return GridPinnedPosition.left;\n    }\n    const rightPinnedColumns = pinnedColumns.right || [];\n    if (rightPinnedColumns.includes(field)) {\n      return GridPinnedPosition.right;\n    }\n    return false;\n  }, [pinnedColumns.left, pinnedColumns.right, checkIfEnabled]);\n  const columnPinningApi = {\n    pinColumn,\n    unpinColumn,\n    getPinnedColumns,\n    setPinnedColumns,\n    isColumnPinned\n  };\n  useGridApiMethod(apiRef, columnPinningApi, 'public');\n  const handleColumnOrderChange = React.useCallback(params => {\n    if (!apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns) {\n      return;\n    }\n    const {\n      column,\n      targetIndex,\n      oldIndex\n    } = params;\n    const delta = targetIndex > oldIndex ? 1 : -1;\n    const latestColumnFields = gridColumnFieldsSelector(apiRef);\n\n    /**\n     * When a column X is reordered to somewhere else, the position where this column X is dropped\n     * on must be moved to left or right to make room for it. The ^^^ below represents the column\n     * which gave space to receive X.\n     *\n     * | X | B | C | D | -> | B | C | D | X | (e.g. X moved to after D, so delta=1)\n     *              ^^^              ^^^\n     *\n     * | A | B | C | X | -> | X | A | B | C | (e.g. X moved before A, so delta=-1)\n     *  ^^^                      ^^^\n     *\n     * If column P is pinned, it will not move to provide space. However, it will jump to the next\n     * non-pinned column.\n     *\n     * | X | B | P | D | -> | B | D | P | X | (e.g. X moved to after D, with P pinned)\n     *              ^^^          ^^^\n     */\n    const siblingField = latestColumnFields[targetIndex - delta];\n    const newOrderedFieldsBeforePinningColumns = [...apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns];\n\n    // The index to start swapping fields\n    let i = newOrderedFieldsBeforePinningColumns.findIndex(currentColumn => currentColumn === column.field);\n    // The index of the field to swap with\n    let j = i + delta;\n\n    // When to stop swapping fields.\n    // We stop one field before because the swap is done with i + 1 (if delta=1)\n    const stop = newOrderedFieldsBeforePinningColumns.findIndex(currentColumn => currentColumn === siblingField);\n    while (delta > 0 ? i < stop : i > stop) {\n      // If the field to swap with is a pinned column, jump to the next\n      while (apiRef.current.isColumnPinned(newOrderedFieldsBeforePinningColumns[j])) {\n        j += delta;\n      }\n      const temp = newOrderedFieldsBeforePinningColumns[i];\n      newOrderedFieldsBeforePinningColumns[i] = newOrderedFieldsBeforePinningColumns[j];\n      newOrderedFieldsBeforePinningColumns[j] = temp;\n      i = j;\n      j = i + delta;\n    }\n    apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns = newOrderedFieldsBeforePinningColumns;\n  }, [apiRef]);\n  useGridApiEventHandler(apiRef, 'columnOrderChange', handleColumnOrderChange);\n  React.useEffect(() => {\n    if (props.pinnedColumns) {\n      apiRef.current.setPinnedColumns(props.pinnedColumns);\n    }\n  }, [apiRef, props.pinnedColumns]);\n};","map":{"version":3,"names":["_extends","React","useTheme","useGridSelector","gridVisibleColumnDefinitionsSelector","gridColumnsTotalWidthSelector","gridColumnPositionsSelector","gridVisibleColumnFieldsSelector","gridClasses","useGridApiMethod","useGridApiEventHandler","gridColumnFieldsSelector","useGridRegisterPipeProcessor","GridPinnedPosition","gridPinnedColumnsSelector","filterColumns","columnPinningStateInitializer","state","props","apiRef","_props$initialState","current","caches","columnPinning","orderedFieldsBeforePinningColumns","model","disableColumnPinning","pinnedColumns","initialState","_props$initialState2","mergeStateWithPinnedColumns","useGridColumnPinning","_props$initialState4","theme","updateHoveredClassOnSiblingRows","useCallback","event","_pinnedColumns$left$l","_pinnedColumns$left","_pinnedColumns$right$","_pinnedColumns$right","Array","isArray","left","right","nbLeftPinnedColumns","length","nbRightPinnedColumns","rowContainer","virtualScrollerRef","index","currentTarget","dataset","rowindex","rowElements","querySelectorAll","row","forEach","closest","virtualScroller","type","classList","add","remove","handleMouseEnter","params","handleMouseLeave","calculateScrollLeft","initialValue","visibleColumnFields","leftPinnedColumns","rightPinnedColumns","direction","colIndex","visibleColumns","columnsTotalWidth","columnPositions","clientWidth","scrollLeft","Math","abs","offsetWidth","computedWidth","offsetLeft","leftPinnedColumnsWidth","rightPinnedColumnsWidth","elementBottom","addColumnMenuItems","columnMenuItems","colDef","pinnable","checkIfCanBeReordered","targetIndex","firstRightPinnedColumnIndex","stateExportPreProcessing","prevState","context","_props$initialState3","_pinnedColumnsToExpor","_pinnedColumnsToExpor2","pinnedColumnsToExport","shouldExportPinnedColumns","exportOnlyDirtyModels","stateRestorePreProcessing","newPinnedColumns","stateToRestore","setState","registerControlState","stateId","propModel","propOnChange","onPinnedColumnsChange","stateSelector","changeEvent","checkIfEnabled","methodName","Error","pinColumn","field","side","isColumnPinned","otherSide","filter","column","setPinnedColumns","unpinColumn","getPinnedColumns","forceUpdate","includes","columnPinningApi","handleColumnOrderChange","oldIndex","delta","latestColumnFields","siblingField","newOrderedFieldsBeforePinningColumns","i","findIndex","currentColumn","j","stop","temp","useEffect"],"sources":["/Users/shyamkansagra/Documents/Code/general/pocket-wallet/node_modules/@mui/x-data-grid-pro/hooks/features/columnPinning/useGridColumnPinning.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useTheme } from '@mui/material/styles';\nimport { useGridSelector, gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector, gridVisibleColumnFieldsSelector, gridClasses, useGridApiMethod, useGridApiEventHandler, gridColumnFieldsSelector } from '@mui/x-data-grid';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { GridPinnedPosition } from './gridColumnPinningInterface';\nimport { gridPinnedColumnsSelector } from './gridColumnPinningSelector';\nimport { filterColumns } from '../../../components/DataGridProVirtualScroller';\nexport const columnPinningStateInitializer = (state, props, apiRef) => {\n  var _props$initialState;\n  apiRef.current.caches.columnPinning = {\n    orderedFieldsBeforePinningColumns: null\n  };\n  let model;\n  if (props.disableColumnPinning) {\n    model = {};\n  } else if (props.pinnedColumns) {\n    model = props.pinnedColumns;\n  } else if ((_props$initialState = props.initialState) != null && _props$initialState.pinnedColumns) {\n    var _props$initialState2;\n    model = (_props$initialState2 = props.initialState) == null ? void 0 : _props$initialState2.pinnedColumns;\n  } else {\n    model = {};\n  }\n  return _extends({}, state, {\n    pinnedColumns: model\n  });\n};\nconst mergeStateWithPinnedColumns = pinnedColumns => state => _extends({}, state, {\n  pinnedColumns\n});\nexport const useGridColumnPinning = (apiRef, props) => {\n  var _props$initialState4;\n  const pinnedColumns = useGridSelector(apiRef, gridPinnedColumnsSelector);\n  const theme = useTheme();\n  // Each visible row (not to be confused with a filter result) is composed of a central .MuiDataGrid-row element\n  // and up to two additional .MuiDataGrid-row's, one for the columns pinned to the left and another\n  // for those on the right side. When hovering any of these elements, the :hover styles are applied only to\n  // the row element that was actually hovered, not its additional siblings. To make it look like a contiguous row,\n  // this method adds/removes the .Mui-hovered class to all of the row elements inside one visible row.\n  const updateHoveredClassOnSiblingRows = React.useCallback(event => {\n    var _pinnedColumns$left$l, _pinnedColumns$left, _pinnedColumns$right$, _pinnedColumns$right;\n    if (props.disableColumnPinning) {\n      return;\n    }\n    if (!Array.isArray(pinnedColumns.left) && !Array.isArray(pinnedColumns.right)) {\n      return;\n    }\n    const nbLeftPinnedColumns = (_pinnedColumns$left$l = (_pinnedColumns$left = pinnedColumns.left) == null ? void 0 : _pinnedColumns$left.length) != null ? _pinnedColumns$left$l : 0;\n    const nbRightPinnedColumns = (_pinnedColumns$right$ = (_pinnedColumns$right = pinnedColumns.right) == null ? void 0 : _pinnedColumns$right.length) != null ? _pinnedColumns$right$ : 0;\n    if (nbLeftPinnedColumns + nbRightPinnedColumns === 0) {\n      return;\n    }\n    const rowContainer = apiRef.current.virtualScrollerRef.current;\n    if (!rowContainer) {\n      return;\n    }\n    const index = event.currentTarget.dataset.rowindex;\n    const rowElements = rowContainer.querySelectorAll(`.${gridClasses.row}[data-rowindex=\"${index}\"]`);\n    rowElements.forEach(row => {\n      // Ignore rows from other grid inside the hovered row\n      if (row.closest(`.${gridClasses.virtualScroller}`) === apiRef.current.virtualScrollerRef.current) {\n        if (event.type === 'mouseenter') {\n          row.classList.add('Mui-hovered');\n        } else {\n          row.classList.remove('Mui-hovered');\n        }\n      }\n    });\n  }, [apiRef, pinnedColumns.left, pinnedColumns.right, props.disableColumnPinning]);\n  const handleMouseEnter = React.useCallback((params, event) => {\n    updateHoveredClassOnSiblingRows(event);\n  }, [updateHoveredClassOnSiblingRows]);\n  const handleMouseLeave = React.useCallback((params, event) => {\n    updateHoveredClassOnSiblingRows(event);\n  }, [updateHoveredClassOnSiblingRows]);\n  useGridApiEventHandler(apiRef, 'rowMouseEnter', handleMouseEnter);\n  useGridApiEventHandler(apiRef, 'rowMouseLeave', handleMouseLeave);\n\n  /**\n   * PRE-PROCESSING\n   */\n  const calculateScrollLeft = React.useCallback((initialValue, params) => {\n    if (props.disableColumnPinning) {\n      return initialValue;\n    }\n    const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef);\n    const [leftPinnedColumns, rightPinnedColumns] = filterColumns(pinnedColumns, visibleColumnFields, theme.direction === 'rtl');\n    if (!params.colIndex || leftPinnedColumns.length === 0 && rightPinnedColumns.length === 0) {\n      return initialValue;\n    }\n    const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);\n    const columnsTotalWidth = gridColumnsTotalWidthSelector(apiRef);\n    const columnPositions = gridColumnPositionsSelector(apiRef);\n    const clientWidth = apiRef.current.virtualScrollerRef.current.clientWidth;\n\n    // When using RTL, `scrollLeft` becomes negative, so we must ensure that we only compare values.\n    const scrollLeft = Math.abs(apiRef.current.virtualScrollerRef.current.scrollLeft);\n    const offsetWidth = visibleColumns[params.colIndex].computedWidth;\n    const offsetLeft = columnPositions[params.colIndex];\n    const leftPinnedColumnsWidth = columnPositions[leftPinnedColumns.length];\n    const rightPinnedColumnsWidth = columnsTotalWidth - columnPositions[columnPositions.length - rightPinnedColumns.length];\n    const elementBottom = offsetLeft + offsetWidth;\n    if (elementBottom - (clientWidth - rightPinnedColumnsWidth) > scrollLeft) {\n      const left = elementBottom - (clientWidth - rightPinnedColumnsWidth);\n      return _extends({}, initialValue, {\n        left\n      });\n    }\n    if (offsetLeft < scrollLeft + leftPinnedColumnsWidth) {\n      const left = offsetLeft - leftPinnedColumnsWidth;\n      return _extends({}, initialValue, {\n        left\n      });\n    }\n    return initialValue;\n  }, [apiRef, pinnedColumns, props.disableColumnPinning, theme.direction]);\n  const addColumnMenuItems = React.useCallback((columnMenuItems, colDef) => {\n    if (props.disableColumnPinning) {\n      return columnMenuItems;\n    }\n    if (colDef.pinnable === false) {\n      return columnMenuItems;\n    }\n    return [...columnMenuItems, 'columnMenuPinningItem'];\n  }, [props.disableColumnPinning]);\n  const checkIfCanBeReordered = React.useCallback((initialValue, {\n    targetIndex\n  }) => {\n    const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef);\n    const [leftPinnedColumns, rightPinnedColumns] = filterColumns(pinnedColumns, visibleColumnFields, theme.direction === 'rtl');\n    if (leftPinnedColumns.length === 0 && rightPinnedColumns.length === 0) {\n      return initialValue;\n    }\n    if (leftPinnedColumns.length > 0 && targetIndex < leftPinnedColumns.length) {\n      return false;\n    }\n    if (rightPinnedColumns.length > 0) {\n      const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);\n      const firstRightPinnedColumnIndex = visibleColumns.length - rightPinnedColumns.length;\n      return targetIndex >= firstRightPinnedColumnIndex ? false : initialValue;\n    }\n    return initialValue;\n  }, [apiRef, pinnedColumns, theme.direction]);\n  const stateExportPreProcessing = React.useCallback((prevState, context) => {\n    var _props$initialState3, _pinnedColumnsToExpor, _pinnedColumnsToExpor2;\n    const pinnedColumnsToExport = gridPinnedColumnsSelector(apiRef.current.state);\n    const shouldExportPinnedColumns =\n    // Always export if the `exportOnlyDirtyModels` property is not activated\n    !context.exportOnlyDirtyModels ||\n    // Always export if the model is controlled\n    props.pinnedColumns != null ||\n    // Always export if the model has been initialized\n    ((_props$initialState3 = props.initialState) == null ? void 0 : _props$initialState3.pinnedColumns) != null ||\n    // Export if the model is not empty\n    ((_pinnedColumnsToExpor = pinnedColumnsToExport.left) != null ? _pinnedColumnsToExpor : []).length > 0 || ((_pinnedColumnsToExpor2 = pinnedColumnsToExport.right) != null ? _pinnedColumnsToExpor2 : []).length > 0;\n    if (!shouldExportPinnedColumns) {\n      return prevState;\n    }\n    return _extends({}, prevState, {\n      pinnedColumns: pinnedColumnsToExport\n    });\n  }, [apiRef, props.pinnedColumns, (_props$initialState4 = props.initialState) == null ? void 0 : _props$initialState4.pinnedColumns]);\n  const stateRestorePreProcessing = React.useCallback((params, context) => {\n    const newPinnedColumns = context.stateToRestore.pinnedColumns;\n    if (newPinnedColumns != null) {\n      apiRef.current.setState(mergeStateWithPinnedColumns(newPinnedColumns));\n    }\n    return params;\n  }, [apiRef]);\n  useGridRegisterPipeProcessor(apiRef, 'scrollToIndexes', calculateScrollLeft);\n  useGridRegisterPipeProcessor(apiRef, 'columnMenu', addColumnMenuItems);\n  useGridRegisterPipeProcessor(apiRef, 'canBeReordered', checkIfCanBeReordered);\n  useGridRegisterPipeProcessor(apiRef, 'exportState', stateExportPreProcessing);\n  useGridRegisterPipeProcessor(apiRef, 'restoreState', stateRestorePreProcessing);\n  apiRef.current.registerControlState({\n    stateId: 'pinnedColumns',\n    propModel: props.pinnedColumns,\n    propOnChange: props.onPinnedColumnsChange,\n    stateSelector: gridPinnedColumnsSelector,\n    changeEvent: 'pinnedColumnsChange'\n  });\n  const checkIfEnabled = React.useCallback(methodName => {\n    if (props.disableColumnPinning) {\n      throw new Error(`MUI: You cannot call \\`apiRef.current.${methodName}\\` when \\`disableColumnPinning\\` is true.`);\n    }\n  }, [props.disableColumnPinning]);\n  const pinColumn = React.useCallback((field, side) => {\n    checkIfEnabled('pinColumn');\n    if (apiRef.current.isColumnPinned(field) === side) {\n      return;\n    }\n    const otherSide = side === GridPinnedPosition.right ? GridPinnedPosition.left : GridPinnedPosition.right;\n    const newPinnedColumns = {\n      [side]: [...(pinnedColumns[side] || []), field],\n      [otherSide]: (pinnedColumns[otherSide] || []).filter(column => column !== field)\n    };\n    apiRef.current.setPinnedColumns(newPinnedColumns);\n  }, [apiRef, checkIfEnabled, pinnedColumns]);\n  const unpinColumn = React.useCallback(field => {\n    checkIfEnabled('unpinColumn');\n    apiRef.current.setPinnedColumns({\n      left: (pinnedColumns.left || []).filter(column => column !== field),\n      right: (pinnedColumns.right || []).filter(column => column !== field)\n    });\n  }, [apiRef, checkIfEnabled, pinnedColumns.left, pinnedColumns.right]);\n  const getPinnedColumns = React.useCallback(() => {\n    checkIfEnabled('getPinnedColumns');\n    return gridPinnedColumnsSelector(apiRef.current.state);\n  }, [apiRef, checkIfEnabled]);\n  const setPinnedColumns = React.useCallback(newPinnedColumns => {\n    checkIfEnabled('setPinnedColumns');\n    apiRef.current.setState(mergeStateWithPinnedColumns(newPinnedColumns));\n    apiRef.current.forceUpdate();\n  }, [apiRef, checkIfEnabled]);\n  const isColumnPinned = React.useCallback(field => {\n    checkIfEnabled('isColumnPinned');\n    const leftPinnedColumns = pinnedColumns.left || [];\n    if (leftPinnedColumns.includes(field)) {\n      return GridPinnedPosition.left;\n    }\n    const rightPinnedColumns = pinnedColumns.right || [];\n    if (rightPinnedColumns.includes(field)) {\n      return GridPinnedPosition.right;\n    }\n    return false;\n  }, [pinnedColumns.left, pinnedColumns.right, checkIfEnabled]);\n  const columnPinningApi = {\n    pinColumn,\n    unpinColumn,\n    getPinnedColumns,\n    setPinnedColumns,\n    isColumnPinned\n  };\n  useGridApiMethod(apiRef, columnPinningApi, 'public');\n  const handleColumnOrderChange = React.useCallback(params => {\n    if (!apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns) {\n      return;\n    }\n    const {\n      column,\n      targetIndex,\n      oldIndex\n    } = params;\n    const delta = targetIndex > oldIndex ? 1 : -1;\n    const latestColumnFields = gridColumnFieldsSelector(apiRef);\n\n    /**\n     * When a column X is reordered to somewhere else, the position where this column X is dropped\n     * on must be moved to left or right to make room for it. The ^^^ below represents the column\n     * which gave space to receive X.\n     *\n     * | X | B | C | D | -> | B | C | D | X | (e.g. X moved to after D, so delta=1)\n     *              ^^^              ^^^\n     *\n     * | A | B | C | X | -> | X | A | B | C | (e.g. X moved before A, so delta=-1)\n     *  ^^^                      ^^^\n     *\n     * If column P is pinned, it will not move to provide space. However, it will jump to the next\n     * non-pinned column.\n     *\n     * | X | B | P | D | -> | B | D | P | X | (e.g. X moved to after D, with P pinned)\n     *              ^^^          ^^^\n     */\n    const siblingField = latestColumnFields[targetIndex - delta];\n    const newOrderedFieldsBeforePinningColumns = [...apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns];\n\n    // The index to start swapping fields\n    let i = newOrderedFieldsBeforePinningColumns.findIndex(currentColumn => currentColumn === column.field);\n    // The index of the field to swap with\n    let j = i + delta;\n\n    // When to stop swapping fields.\n    // We stop one field before because the swap is done with i + 1 (if delta=1)\n    const stop = newOrderedFieldsBeforePinningColumns.findIndex(currentColumn => currentColumn === siblingField);\n    while (delta > 0 ? i < stop : i > stop) {\n      // If the field to swap with is a pinned column, jump to the next\n      while (apiRef.current.isColumnPinned(newOrderedFieldsBeforePinningColumns[j])) {\n        j += delta;\n      }\n      const temp = newOrderedFieldsBeforePinningColumns[i];\n      newOrderedFieldsBeforePinningColumns[i] = newOrderedFieldsBeforePinningColumns[j];\n      newOrderedFieldsBeforePinningColumns[j] = temp;\n      i = j;\n      j = i + delta;\n    }\n    apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns = newOrderedFieldsBeforePinningColumns;\n  }, [apiRef]);\n  useGridApiEventHandler(apiRef, 'columnOrderChange', handleColumnOrderChange);\n  React.useEffect(() => {\n    if (props.pinnedColumns) {\n      apiRef.current.setPinnedColumns(props.pinnedColumns);\n    }\n  }, [apiRef, props.pinnedColumns]);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}